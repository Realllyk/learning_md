
## juc包的常用类

### 线程池相关：

- `ThreadPoolExecutor`：
    - 最核心的线程池类，用于创建和管理线程池。
    - 通过它可以灵活地配置线程池的参数，例如核心线程数、最大线程数、任务队列等，以满足不同的并发处理需求。
- `Executors`：
    - 线程池<span style="color: blue;">工厂类</span>，提供了一系列静态方法来创建不同类型的线程池，例如：
        - `newFixedThreadPool`（创建固定线程数的线程池）
        - `newCachedThreadPool`（创建可缓存线程池）
        - `newSingleThreadExecutor`（创建单线程线程池）


 **`ThreadPoolExecutor` 和 `Executors` 的关系**：
`Executors` 和 `ThreadPoolExecutor` 之间的关系可以理解为：
- `ThreadPoolExecutor` **是 Java 线程池的核心实现**，提供了**高度可配置**的线程池管理功能。
- `Executors` **是一个线程池的** **工厂类**，它提供了一系列静态方法来创建 `ThreadPoolExecutor` 的实例。

换句话说，**`Executors.newFixedThreadPool()` 等方法本质上返回的是 `ThreadPoolExecutor` 实例**，只是 `Executors` 负责了简化创建过程，隐藏了 `ThreadPoolExecutor` 复杂的构造细节。


### 并发集合类：

- `ConcurrentHashMap`：
    - 线程安全的哈希映射表，用于在多线程环境下高效地存储和访问键值对。
    - 采用**分段锁（Segmented Locking）**，允许多个线程同时访问不同的段，提高并发性能。
    - 在高并发场景下比传统的 `Hashtable` 性能更好。
- `CopyOnWriteArrayList`：
    - 线程安全的列表，在对列表进行修改操作时，会**创建一个新的底层数组**，将修改操作应用到新数组上，而读操作仍然可以在旧数组上进行。
    - 适用于**读多写少**的场景，例如缓存、黑名单等。


### 同步工具类：
- `CountDownLatch`：
    - 允许一个或多个线程**等待**另一组线程完成操作后再继续执行。
    - 通过一个**计数器**来实现，计数器初始值为线程个数，每当一个线程调用 `countDown()` 方法，计数器减一。<span style="color: red;">（计数器不可重置，只能用一次）</span>
    - 当计数器变为 0 时，所有等待的线程会继续执行。
    - 适用于任务依赖的场景，如**多个线程并行执行任务，待全部完成后再进行下一步**。

```java
import java.util.concurrent.CountDownLatch;


class Worker extends Thread {
    private CountDownLatch latch;
    
    public Worker(CountDownLatch latch) {
        this.latch = latch;
    }

    public void run() {
        System.out.println(Thread.currentThread().getName() + " 执行任务...");
        latch.countDown(); // 计数器减 1
    }
}

public class CountDownLatchDemo {
    public static void main(String[] args) throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(3); // 计数器初始化为 3

        // 启动 3 个子线程
        new Worker(latch).start();
        new Worker(latch).start();
        new Worker(latch).start();

        latch.await(); // 等待计数器归零，主线程才继续执行
        System.out.println("所有子线程任务完成，主线程继续执行...");
    }
}

```
**执行流程**
1. `CountDownLatch(3)` 设置计数器为 3，表示有 3 个子任务。
2. `latch.countDown()` 每个线程执行完任务后计数器减 1。
3. `latch.await()` 让主线程**等待**，直到计数器减为 0，主线程才继续执行。


- `CyclicBarrier`：
    - 让一组线程**相互等待**，直到所有线程都到达某个屏障点后，才能继续执行。
    - 与 `CountDownLatch` **不同**，`CyclicBarrier` 可以**重复使用**，当所有线程都到达屏障点，计数器会重置。
    - 适用于**多轮任务执行**的场景，如**多个线程并行计算后同步，下一轮任务需要它们全部完成**。

```java
import java.util.concurrent.CyclicBarrier;

class Task extends Thread {
    private CyclicBarrier barrier;

    public Task(CyclicBarrier barrier) {
        this.barrier = barrier;
    }

    public void run() {
        System.out.println(Thread.currentThread().getName() + " 到达屏障点");
        try {
            barrier.await(); // 等待所有线程到达屏障点
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + " 继续执行");
    }
}

public class CyclicBarrierDemo {
    public static void main(String[] args) {
        CyclicBarrier barrier = new CyclicBarrier(3, () -> System.out.println("所有线程都到达屏障点，开始下一轮任务..."));

        new Task(barrier).start();
        new Task(barrier).start();
        new Task(barrier).start();
    }
}

```

**执行流程**：
1. `CyclicBarrier(3)` 创建一个**3 线程同步点**，所有线程必须等待彼此到达。
2. `barrier.await()` 让线程等待，直到所有 3 个线程都调用 `await()`。
3. 当所有线程到达后，执行屏障动作 `() -> System.out.println("开始下一轮任务")`。
4. **屏障自动重置**，下一轮任务可以重新使用。


- `Semaphore`：
    - 信号量，**用于控制并发访问的许可数量**。
    - 线程在访问资源前需要**获取许可**，如果没有可用许可，则线程会阻塞等待，直到有其他线程释放许可。
    - 适用于**限流**（如数据库连接池、线程池中的线程数量控制等）。
```java
import java.util.concurrent.Semaphore;

class Worker extends Thread {
    private Semaphore semaphore;
    
    public Worker(Semaphore semaphore) {
        this.semaphore = semaphore;
    }

    public void run() {
        try {
            semaphore.acquire(); // 获取许可（如果无可用许可，则阻塞）
            System.out.println(Thread.currentThread().getName() + " 获取许可，执行任务...");
            Thread.sleep(2000); // 模拟任务
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            System.out.println(Thread.currentThread().getName() + " 释放许可");
            semaphore.release(); // 释放许可
        }
    }
}

public class SemaphoreDemo {
    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(2); // 允许 2 个线程同时执行

        for (int i = 0; i < 5; i++) {
            new Worker(semaphore).start();
        }
    }
}

```

**执行流程**：
1. `Semaphore(2)` 只允许**2 个线程**同时执行任务。
2. `semaphore.acquire()` 获取许可，若无可用许可，则线程阻塞等待。
3. 任务完成后，`semaphore.release()` 释放许可，其他线程可以继续执行。


 **`CountDownLatch` vs. `CyclicBarrier` vs. `Semaphore` 总结**:

| 工具类              | 主要作用                      | 计数器是否可重置   | 线程是否相互等待  | 适用场景                    |
| ---------------- | ------------------------- | ---------- | --------- | ----------------------- |
| `CountDownLatch` | **线程等待依赖**（主线程等待子线程完成）    | ❌ **不可重置** | ❌ **不需要** | **任务依赖**（如主线程等待多个子任务完成） |
| `CyclicBarrier`  | **一组线程同步点**（所有线程都到达后继续执行） | ✅ **可重置**  | ✅ **需要**  | **多轮任务**（如并行计算后同步结果）    |
| `Semaphore`      | **控制并发访问的线程数**            | ✅ **可重用**  | ❌ **不需要** | **资源限流**（如数据库连接池、限流控制）  |

### 原子类 - **`AtomicInteger`**： 
- 原子整数类，提供了对整数类型的原子操作，如 **自增、自减、比较并交换** 等。 
	- 通过 **硬件级别的原子指令** 来保证操作的原子性和线程安全性，避免了使用锁带来的性能开销。 
	-  在多线程环境下对整数进行 **计数、状态标记** 等操作时非常方便。
- **`AtomicReference`**： 
	- 原子引用类，用于 **对对象引用进行原子操作**。
	- 可以保证在多线程环境下，对对象的更新操作是原子的，即 **要么全部成功，要么全部失败**，不会出现数据不一致的情况。 
	- 适用于 **无锁数据结构** 场景，例如 **共享对象的原子更新**。


---


