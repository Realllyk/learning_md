
## juc包的常用类

### 线程池相关：

- `ThreadPoolExecutor`：
    - 最核心的线程池类，用于创建和管理线程池。
    - 通过它可以灵活地配置线程池的参数，例如核心线程数、最大线程数、任务队列等，以满足不同的并发处理需求。
- `Executors`：
    - 线程池<span style="color: blue;">工厂类</span>，提供了一系列静态方法来创建不同类型的线程池，例如：
        - `newFixedThreadPool`（创建固定线程数的线程池）
        - `newCachedThreadPool`（创建可缓存线程池）
        - `newSingleThreadExecutor`（创建单线程线程池）


 **`ThreadPoolExecutor` 和 `Executors` 的关系**：
`Executors` 和 `ThreadPoolExecutor` 之间的关系可以理解为：
- `ThreadPoolExecutor` **是 Java 线程池的核心实现**，提供了**高度可配置**的线程池管理功能。
- `Executors` **是一个线程池的** **工厂类**，它提供了一系列静态方法来创建 `ThreadPoolExecutor` 的实例。

换句话说，**`Executors.newFixedThreadPool()` 等方法本质上返回的是 `ThreadPoolExecutor` 实例**，只是 `Executors` 负责了简化创建过程，隐藏了 `ThreadPoolExecutor` 复杂的构造细节。


### 并发集合类：

- `ConcurrentHashMap`：
    - 线程安全的哈希映射表，用于在多线程环境下高效地存储和访问键值对。
    - 采用**分段锁（Segmented Locking）**，允许多个线程同时访问不同的段，提高并发性能。
    - 在高并发场景下比传统的 `Hashtable` 性能更好。
- `CopyOnWriteArrayList`：
    - 线程安全的列表，在对列表进行修改操作时，会**创建一个新的底层数组**，将修改操作应用到新数组上，而读操作仍然可以在旧数组上进行。
    - 适用于**读多写少**的场景，例如缓存、黑名单等。


### 同步工具类：
- `CountDownLatch`：
    - 允许一个或多个线程**等待**另一组线程完成操作后再继续执行。
    - 通过一个**计数器**来实现，计数器初始值为线程个数，每当一个线程调用 `countDown()` 方法，计数器减一。<span style="color: red;">（计数器不可重置，只能用一次）</span>
    - 当计数器变为 0 时，所有等待的线程会继续执行。
    - 适用于任务依赖的场景，如**多个线程并行执行任务，待全部完成后再进行下一步**。

```java
import java.util.concurrent.CountDownLatch;


class Worker extends Thread {
    private CountDownLatch latch;
    
    public Worker(CountDownLatch latch) {
        this.latch = latch;
    }

    public void run() {
        System.out.println(Thread.currentThread().getName() + " 执行任务...");
        latch.countDown(); // 计数器减 1
    }
}

public class CountDownLatchDemo {
    public static void main(String[] args) throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(3); // 计数器初始化为 3

        // 启动 3 个子线程
        new Worker(latch).start();
        new Worker(latch).start();
        new Worker(latch).start();

        latch.await(); // 等待计数器归零，主线程才继续执行
        System.out.println("所有子线程任务完成，主线程继续执行...");
    }
}

```
**执行流程**
1. `CountDownLatch(3)` 设置计数器为 3，表示有 3 个子任务。
2. `latch.countDown()` 每个线程执行完任务后计数器减 1。
3. `latch.await()` 让主线程**等待**，直到计数器减为 0，主线程才继续执行。


- `CyclicBarrier`：
    - 让一组线程**相互等待**，直到所有线程都到达某个屏障点后，才能继续执行。
    - 与 `CountDownLatch` **不同**，`CyclicBarrier` 可以**重复使用**，当所有线程都到达屏障点，计数器会重置。
    - 适用于**多轮任务执行**的场景，如**多个线程并行计算后同步，下一轮任务需要它们全部完成**。

```java
import java.util.concurrent.CyclicBarrier;

class Task extends Thread {
    private CyclicBarrier barrier;

    public Task(CyclicBarrier barrier) {
        this.barrier = barrier;
    }

    public void run() {
        System.out.println(Thread.currentThread().getName() + " 到达屏障点");
        try {
            barrier.await(); // 等待所有线程到达屏障点
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + " 继续执行");
    }
}

public class CyclicBarrierDemo {
    public static void main(String[] args) {
        CyclicBarrier barrier = new CyclicBarrier(3, () -> System.out.println("所有线程都到达屏障点，开始下一轮任务..."));

        new Task(barrier).start();
        new Task(barrier).start();
        new Task(barrier).start();
    }
}

```

**执行流程**：
1. `CyclicBarrier(3)` 创建一个**3 线程同步点**，所有线程必须等待彼此到达。
2. `barrier.await()` 让线程等待，直到所有 3 个线程都调用 `await()`。
3. 当所有线程到达后，执行屏障动作 `() -> System.out.println("开始下一轮任务")`。
4. **屏障自动重置**，下一轮任务可以重新使用。


- `Semaphore`：
    - 信号量，**用于控制并发访问的许可数量**。
    - 线程在访问资源前需要**获取许可**，如果没有可用许可，则线程会阻塞等待，直到有其他线程释放许可。
    - 适用于**限流**（如数据库连接池、线程池中的线程数量控制等）。
```java
import java.util.concurrent.Semaphore;

class Worker extends Thread {
    private Semaphore semaphore;
    
    public Worker(Semaphore semaphore) {
        this.semaphore = semaphore;
    }

    public void run() {
        try {
            semaphore.acquire(); // 获取许可（如果无可用许可，则阻塞）
            System.out.println(Thread.currentThread().getName() + " 获取许可，执行任务...");
            Thread.sleep(2000); // 模拟任务
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            System.out.println(Thread.currentThread().getName() + " 释放许可");
            semaphore.release(); // 释放许可
        }
    }
}

public class SemaphoreDemo {
    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(2); // 允许 2 个线程同时执行

        for (int i = 0; i < 5; i++) {
            new Worker(semaphore).start();
        }
    }
}

```

**执行流程**：
1. `Semaphore(2)` 只允许**2 个线程**同时执行任务。
2. `semaphore.acquire()` 获取许可，若无可用许可，则线程阻塞等待。
3. 任务完成后，`semaphore.release()` 释放许可，其他线程可以继续执行。


 **`CountDownLatch` vs. `CyclicBarrier` vs. `Semaphore` 总结**:

| 工具类              | 主要作用                      | 计数器是否可重置   | 线程是否相互等待  | 适用场景                    |
| ---------------- | ------------------------- | ---------- | --------- | ----------------------- |
| `CountDownLatch` | **线程等待依赖**（主线程等待子线程完成）    | ❌ **不可重置** | ❌ **不需要** | **任务依赖**（如主线程等待多个子任务完成） |
| `CyclicBarrier`  | **一组线程同步点**（所有线程都到达后继续执行） | ✅ **可重置**  | ✅ **需要**  | **多轮任务**（如并行计算后同步结果）    |
| `Semaphore`      | **控制并发访问的线程数**            | ✅ **可重用**  | ❌ **不需要** | **资源限流**（如数据库连接池、限流控制）  |

### 原子类 - **`AtomicInteger`**： 
- 原子整数类，提供了对整数类型的原子操作，如 **自增、自减、比较并交换** 等。 
	- 通过 **硬件级别的原子指令** 来保证操作的原子性和线程安全性，避免了使用锁带来的性能开销。 
	-  在多线程环境下对整数进行 **计数、状态标记** 等操作时非常方便。
- **`AtomicReference`**： 
	- 原子引用类，用于 **对对象引用进行原子操作**。
	- 可以保证在多线程环境下，对对象的更新操作是原子的，即 **要么全部成功，要么全部失败**，不会出现数据不一致的情况。 
	- 适用于 **无锁数据结构** 场景，例如 **共享对象的原子更新**。


---


## 怎么保证多线程安全？ 

### **synchronized 关键字**: 
 可以使用 `synchronized` 关键字来同步代码块或方法，确保同一时刻只有一个线程可以访问这些代码。对象锁是通过 `synchronized` 关键字锁定对象的监视器（monitor）来实现的。 
```java 
public synchronized void someMethod() {/* ... */ } 

public void anotherMethod() { 
	synchronized (someObject) { 
		/* ... */ 
	} 
}
```

### **volatile 关键字**: 
`volatile` 关键字用于变量，确保所有线程看到的该变量的最新值，而不是可能存储在本地寄存器中的副本。
```java
public volatile int sharedVariable;
```

### **Lock 接口和 ReentrantLock 类**: 
`java.util.concurrent.locks.Lock` 接口提供了比 `synchronized` 更强大的锁定机制，`ReentrantLock` 是一个实现该接口的例子，提供了更灵活的锁管理和更高的性能。 

`ReentrantLock` 属于 **`java.util.concurrent.locks`** 包，是一种 **显式锁**，其实现是基于 **AQS（AbstractQueuedSynchronizer）**，不像 `synchronized` 那样基于对象的 Monitor 机制。

**特点**：
- **可重入**：一个线程可以多次获取同一个锁，而不会被阻塞。
- **支持公平/非公平锁**：可选择 **公平锁**（FIFO 机制）或者 **非公平锁**（默认，效率更高）。
- **支持超时获取锁**：可以尝试一段时间内获取锁，避免线程一直阻塞。
- **支持中断**：`synchronized` 不能响应线程中断，而 `ReentrantLock` 允许在等待锁时被中断。

``` java 
private final ReentrantLock lock = new ReentrantLock(); 
public void someMethod() { 
	lock.lock(); 
	try { 
		/* ... */ 
	} finally { 
		lock.unlock(); 
	} 
}
```

#### **synchronized 与 ReentrantLock 对比**

| 特性        | `synchronized`             | `ReentrantLock`      |
| --------- | -------------------------- | -------------------- |
| **实现方式**  | 依赖 **JVM** 内部的 **Monitor** | 基于 **AQS** 机制        |
| **是否可重入** | **是**                      | **是**                |
| **公平性**   | **非公平**，JVM 自行优化           | 可选择 **公平** 或 **非公平** |
| **中断响应**  | **不支持**，线程必须执行完同步块         | **支持**，可以在等待锁时被中断    |
| **超时获取锁** | **不支持**                    | **支持**，`tryLock()`   |
| **性能**    | **JVM 会进行锁优化**，适用于大多数场景    | **性能更优**，适用于高并发场景    |
| **使用场景**  | 代码简洁，适用于 **一般同步**          | 需要更高灵活性时使用           |


#### 支持中断（Interruptible）：
在多线程编程中，**支持中断** 是指 **当线程在等待获取锁时，可以响应中断信号，从而提前终止等待（BLOCKED状态）**。如果一个锁 **不支持中断**，那么当线程尝试获取该锁时，它会一直等待，直到获取锁或者线程被强制终止。

##### **1. synchronized 不支持中断**
当线程尝试进入一个被 `synchronized` 保护的代码块时，如果锁已经被其他线程持有，线程会**一直等待**，无法中断，除非线程被强制终止（例如 `Thread.stop()`，但这种方式已经被弃用）。

synchronized是支持从`sleep()`，`wait()`, `join()`方法中中断的。

#####  **2. ReentrantLock 支持中断**

`ReentrantLock` 提供 `lockInterruptibly()` 方法，它允许线程在等待锁的过程中 **响应中断信号**，如果被中断，则会抛出 `InterruptedException`，线程可以选择终止或执行其他逻辑。

### **原子类**:
ava 并发库（`java.util.concurrent.atomic`）提供了原子类，如 `AtomicInteger`、`AtomicLong` 等，这些类提供了原子操作，可以用于更新基本类型的变量而无需额外的同步。
```java
AtomicInteger counter = new AtomicInteger(0);
int newValue = counter.incrementAndGet();
```

### 线程局部变量
`ThreadLocal` 类可以为每个线程提供独立的变量副本，这样每个线程都拥有自己的变量，消除了竞争条件。
这在Spring Boot后端项目中可以用于获取当前用户的id：通过parse JWT令牌

```java 
ThreadLocal<Integer> threadLocalVar = new ThreadLocal<>(); 

threadLocalVar.set(10); 
int value = threadLocalVar.get();
```

### **并发集合**:
使用 `java.util.concurrent` 包中的线程安全集合，如 `ConcurrentHashMap`、`ConcurrentLinkedQueue` 等，这些集合内部已经实现了线程安全的逻辑。

### **JUC 工具类**: 
使用 `java.util.concurrent` 包中的一些工具类可以用于控制线程间的同步和协作。例如：
- `Semaphore`
- `CyclicBarrier`


---

## Java中常用的锁

Java中的锁是用于管理多线程并发访问共享资源的关键机制。锁可以确保在任意给定时间内只有一个线程可以访问特定的资源，从而避免数据竞争和不一致性。Java 提供了多种锁机制，可以分为以下几类：

### **1. 内置锁（synchronized）**
Java中的 `synchronized` 关键字是内置锁机制的基础，可以用于方法或代码块。当一个线程进入 `synchronized` 代码块或方法时，它会获取具体对象的锁；当线程离开该代码块或方法时，锁会被释放。如果其他线程尝试获取同一个对象的锁，它们将被阻塞，直到锁被释放。

`synchronized` 机制有无锁、偏向锁、轻量级锁和重量级锁几个级别：
- **偏向锁**：适用于当一个线程进入同步块时，如果没有其他线程竞争，就会使用偏向锁，以减少锁的开销。
- **轻量级锁**：使用线程栈上的数据结构，避免了操作系统级别的锁，从而减少互斥锁带来的性能损耗。
- **重量级锁**：当线程竞争激烈时，系统会自动升级为重量级锁，使用操作系统级的互斥锁进行管理。


---

### **2. ReentrantLock**
`ReentrantLock`（`java.util.concurrent.locks.ReentrantLock`）是一种 **显式的锁**，提供了比 `synchronized` **更高级的功能**，如：
- **可中断的锁等待**
- **公平锁和非公平锁**
- **支持多个条件变量**

`ReentrantLock` 通过 `lock()` 和 `unlock()` 方法来获取和释放锁：
- **公平锁**：按照锁请求的顺序来分配，避免锁分配的饥饿现象，但可能增加锁的等待时间。
- **非公平锁**（默认）：不保证线程获取锁的顺序，提高性能，但可能会造成某些线程的饥饿现象。

**示例：**
```java
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockExample {
    private final ReentrantLock lock = new ReentrantLock();

    public void method() {
        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + " 获取了锁");
        } finally {
            lock.unlock();
        }
    }
}
```


### **3. 读写锁（ReadWriteLock）**

`ReadWriteLock`（`java.util.concurrent.locks.ReadWriteLock`）提供了一种锁机制：
- **允许多个读线程同时访问共享资源**
- **但只允许一个写线程**

读写锁通常用于 **读操作远多于写操作** 的场景，以提高并发性能。
**示例：**

```java
import java.util.concurrent.locks.ReentrantReadWriteLock;
public class ReadWriteLockExample {     
	private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
	
	public void read() {         
		rwLock.readLock().lock();         
		try {             
			System.out.println("读取数据...");         
		} finally {             
			rwLock.readLock().unlock();         
		}     
	} 
	   
	public void write() {         
		rwLock.writeLock().lock();         
		try {             
			System.out.println("写入数据...");         
		} finally {             
			rwLock.writeLock().unlock();        
		}     
	} 
}
```


### **4. 乐观锁和悲观锁**

#### **悲观锁（Pessimistic Locking）**

假设最坏情况，即数据很可能被其他线程修改，因此在访问数据前**锁定资源**，避免其他线程修改。`synchronized` 和 `ReentrantLock` 都属于悲观锁。

#### **乐观锁（Optimistic Locking）**

假设数据很少被并发修改，因此 **不锁定资源**，而是基于 **版本号（Version）** 或 **CAS（Compare and Swap）** 机制来保证数据一致性。适用于读操作远多于写操作的情况。

**示例（使用 Atomic 变量实现乐观锁）：**
原子类都是基于 **CAS（Compare-And-Swap, 比较并交换）** 操作，实现**无锁并发控制**，从而避免了 `synchronized` 或 `ReentrantLock` 等悲观锁带来的线程阻塞。
java
``` java
import java.util.concurrent.atomic.AtomicInteger;

public class OptimisticLockExample {
    private final AtomicInteger count = new AtomicInteger(0);

    public void increment() {
        int newValue = count.incrementAndGet();
        System.out.println("新值: " + newValue);
    }
}

```


### **5. 自旋锁**

**自旋锁** 是一种特殊的锁机制，**线程在等待锁时会持续检查锁是否可用，而不是放弃 CPU 进入阻塞状态**。自旋锁通常使用 **CAS（Compare and Swap）** 机制实现，适用于 **锁的持有时间短，线程切换成本较高** 的情况。

**自旋锁的优缺点**

- **优点**：可以减少线程切换的开销，提高性能。
- **缺点**：如果锁被长时间持有，自旋锁会消耗大量 CPU 资源。


## Java并发工具
Java 中一些常用的并发工具，它们位于 `java.util.concurrent` 包中，常见的有：
### **CountDownLatch**
 CountDownLatch 是一个同步辅助类，它允许一个或多个线程等待其他线程完成操作。它使用一个计数器进行初始化，调用 `countDown()` 方法会使计数器减一，当计数器的值减为 0 时，等待的线程会被唤醒。可以把它想象成一个倒计时器，当倒计时结束（计数器为 0）时，等待的事件就会发生。例如代码：
import java.util.concurrent.CountDownLatch;
```java
public class CountDownLatchExample {
    public static void main(String[] args) throws InterruptedException {
        int numberOfThreads = 3;
        CountDownLatch latch = new CountDownLatch(numberOfThreads);

        // 创建并启动三个工作线程
        for (int i = 0; i < numberOfThreads; i++) {
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + " 正在工作");
                try {
                    Thread.sleep(1000); // 模拟工作的时间
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                latch.countDown(); // 完成工作，计数器减一
                System.out.println(Thread.currentThread().getName() + " 完成工作");
            }).start();
        }

        System.out.println("主线程等待工作线程完成");
        latch.await(); // 主线程等待，直到计数器为 0
        System.out.println("所有工作线程已完成，主线程继续执行");
    }
}
```


###  **CyclicBarrier**：
CyclicBarrier 允许一组线程互相等待，直到到达一个公共的屏障点。当所有线程都到达这个屏障点后，它们可以继续执行后续操作，并且这个屏障可以被重复循环使用。与 `CountDownLatch` 不同，`CyclicBarrier` 侧重于线程间的相互等待，而不是等待某些操作完成。例如代码：

```java
import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierExample {
    public static void main(String[] args) {
        int numberOfThreads = 3;
        CyclicBarrier barrier = new CyclicBarrier(numberOfThreads, () -> {
            System.out.println("所有线程都到达了屏障，继续执行后续操作");
        });

        for (int i = 0; i < numberOfThreads; i++) {
            new Thread(() -> {
                try {
                    System.out.println(Thread.currentThread().getName() + " 正在运行");
                    Thread.sleep(1000); // 模拟运行时间
                    barrier.await(); // 等待其他线程
                    System.out.println(Thread.currentThread().getName() + " 已经通过屏障");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```

### **Semaphore**：
Semaphore 是一个计数信号量，用于控制同时访问某个共享资源的线程数量。通过 `acquire()` 方法获取许可，使用 `release()` 方法释放许可。如果没有许可可用，线程将被阻塞，直到有许可被释放。可以用于限制对某些资源（如数据库连接池、文件操作等）的并发访问量。代码如下：

``` java
import java.util.concurrent.Semaphore;

public class SemaphoreExample {
    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(2); // 允许 2 个线程同时访问

        for (int i = 0; i < 5; i++) {
            new Thread(() -> {
                try {
                    semaphore.acquire(); // 获取许可
                    System.out.println(Thread.currentThread().getName() + " 获取了许可");
                    Thread.sleep(2000); // 模拟资源使用
                    System.out.println(Thread.currentThread().getName() + " 释放了许可");
                    semaphore.release(); // 释放许可
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```

### **Future 和 Callable**：
Callable 是一个类似于 `Runnable` 的接口，但它可以返回结果，并且可以抛出异常。`Future` 用于表示一个异步计算的结果，可以通过它来获取 `Callable` 任务的执行结果或取消任务。代码如下：

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class FutureCallableExample {
    public static void main(String[] args) throws Exception {
        ExecutorService executorService = Executors.newSingleThreadExecutor();

        Callable<Integer> callable = () -> {
            System.out.println(Thread.currentThread().getName() + " 开始执行 Callable 任务");
            Thread.sleep(2000); // 模拟耗时操作
            return 42; // 返回结果
        };

        Future<Integer> future = executorService.submit(callable);
        System.out.println("主线程继续执行其他任务");

        try {
            Integer result = future.get(); // 等待 Callable 任务完成并获取结果
            System.out.println("Callable 任务的结果: " + result);
        } catch (Exception e) {
            e.printStackTrace();
        }

        executorService.shutdown();
    }
}
```

<span style="color: orange;">实现了Callbel的类对象也可以封装到FutureTask中，在传入到Thread对象进行对象，但是上面使用线程池的方法更好。因为线程池避免频繁创建和销毁线程，提高性能， 限制同时运行的线程数量，防止资源耗尽。</span>


---


## `synchronized`的工作原理
`synchronized` 是 Java 提供的原子性内置锁，这种内置的并且用户看不到的锁也被称为 **监视器锁**。

使用 `synchronized` 之后，会在编译之后在同步代码块前后加上 `monitorenter` 和 `monitorexit` 字节码指令。其他被操作系统唤醒的线程层层后续获取锁。它的作用主要就是实现用于线程同步和解决共享变量的内存可见性问题。

执行 `monitorenter` 指令时会尝试获取对象锁，如果对象没有被锁住或者已经获得了锁，锁的计数器 `+1`。此时其他竞争的线程则会进入阻止等待队列中。执行 `monitorexit` 指令时则会把计数器 `-1`，当计数器值为 `0` 时，**则完全释放锁**，处于等待队列中的线程再继续竞争锁。

`synchronized` 是 **排它锁**，当一个线程获取锁之后，其他线程必须等待该线程释放锁才能继续执行。而且由于 Java 的线程和操作系统线程是一对一的，线程被阻塞或唤醒时都会从用户态切换到内核态，这种转换非常消耗性能。

从内存语义来说，加锁的过程会**清除工作内存中的共享变量**，再从主存读取，而释放锁的过程则会**将工作内存中的共享变量写回主存**。

实际上大部分时候我们认为 `synchronized` 捕获了 `monitorenter`，但为了更清楚地了解其运行机制，还是要再细一点。

![[synchronized.png]]

如果深入到源码来说，`synchronized` 其实是**有两个队列** `waitSet` **和** `entryList`。
1. 当多个线程进入同步代码块时，首先进入 `entryList`。
2. 有一个线程获取到 **对象锁**，执行同步代码，并且让 **锁的计数器+1**。
3. 如果线程调用 `wait()` 方法时，则当前线程会进入 `waitSet`，**计数器-1**，同时进入 `waitSet` 等待被唤醒，调用 `notify()` 或 `notifyAll()` 后会进入 `entryList` 竞争锁。
4. 如果线程执行完毕，同样释放锁，计数器 `-1`，当前线程置为 `null`。

|**概念**|**解释**|
|---|---|
|**主存（Main Memory）**|所有线程共享的内存区域（堆内存，存放共享变量）|
|**工作内存（Working Memory）**|线程私有的缓存区域（线程执行时的本地副本）|
|**可见性问题**|由于工作内存的存在，一个线程修改变量后，其他线程可能无法立即看到最新值|
|**synchronized 的作用**|1. 确保修改后的变量值及时同步回主存 2. 确保其他线程读取的是主存最新数据|

`synchronized` 通过**强制刷新主存**和**从主存读取最新值**来解决多线程之间的可见性问题。类似地，`volatile` 关键字也可以保证变量的可见性，但它不能保证原子性，而 `synchronized` 可以同时保证可见性和原子性。


## ReentrantLock 工作原理

`ReentrantLock` 的底层实现主要依赖于 `AbstractQueuedSynchronizer (AQS)` 这个抽象类。AQS 是一个提供了基本同步机制的框架，其中包括了队列、状态值等。

`ReentrantLock` 在 AQS 的基础上通过内部类 `Sync` 来实现具体的锁操作。不同的 `Sync` 子类实现了公平锁和非公平锁的不同逻辑：

- **可中断性**：`ReentrantLock` 实现了可中断性，这意味着线程在等待锁的过程中，可以被其他线程中断而提前结束等待。在底层，`ReentrantLock` 使用了与 `LockSupport.park()` 和 `LockSupport.unpark()` 相关的机制来实现可中断性。
- **设置超时时间**：`ReentrantLock` 支持在尝试获取锁时设置超时时间，即等待一段时间后如果还未获得锁，则放弃锁的获取。这是通过内部的 `tryAcquireNanos` 方法来实现的。
- **公平锁和非公平锁**：在默认情况下，`ReentrantLock` 对象是**非公平锁**。公平锁是按照线程等待的顺序来获取锁，而非公平锁允许多个线程在同一时刻竞争锁，不考虑它们申请锁的顺序。公平锁可以通过创建 `ReentrantLock` 时传入 `true` 来指定，例如：

```java
ReentrantLock fairLock = new ReentrantLock(true);
```

- **多个条件变量**：`ReentrantLock` 支持多个条件变量，每个条件变量可以与一个 `ReentrantLock` 关联。这使得线程可以更灵活地进行等待和唤醒操作，而不仅仅是基于对象监视器的 `wait()` 和 `notify()`。多个条件变量的实现依赖于 `Condition` 接口，例如

```java
ReentrantLock lock = new ReentrantLock();
Condition condition = lock.newCondition();

// 使用下面方法进行等待和唤醒
condition.await();
condition.signal();
```

- **可重入性**：`ReentrantLock` 支持可重入性，即同一个线程可以多次获得同一把锁，而不会造成死锁。这是通过内部的 `holdCount` 计数来实现的。当一个线程多次获取锁时，`holdCount` 递增，释放锁时递减，只有当 `holdCount` 为零时，其他线程才有机会获取锁。


### Condition 的作用是什么？
在 `ReentrantLock` 中，**多个条件变量（Condition）** 允许线程在不同的条件下等待和唤醒，而不像 `synchronized` 只能使用 `wait()` 和 `notifyAll()` 进行粗粒度的线程控制。

**条件变量的作用**：
- 允许线程在满足特定条件时等待，直到被唤醒。
- 支持多个不同的等待队列，使得可以 **分别控制不同的线程组**，避免不必要的线程唤醒，提高效率。
- 让 `await()` 方法可以替代 `Object.wait()`，`signal()` 方法可以替代 `Object.notify()`，但提供了更灵活的控制。

#### **示例：生产者-消费者问题**

假设有两个线程：
1. **生产者** 线程，负责放入数据。
2. **消费者** 线程，负责取出数据。

**如果容器为空，消费者应等待；如果容器满了，生产者应等待。**
**使用 `synchronized` 只能有一个 `waitSet`**，无法精确控制生产者或消费者谁应该被唤醒：
```java
synchronized (lock) {
    while (queue.isEmpty()) {
        lock.wait(); // 消费者等待
    }
    // 取出数据
    lock.notifyAll(); // 只能通知所有等待的线程
}

```
这样 `notifyAll()` 可能会误唤醒生产者，而生产者本应继续等待。


### **使用 `ReentrantLock` 和 `Condition`**

`ReentrantLock` 允许创建多个 `Condition`，从而**区分生产者和消费者的等待队列**：
```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.LinkedList;

public class ProducerConsumerExample {
    private static final Lock lock = new ReentrantLock();
    private static final Condition notEmpty = lock.newCondition();  // 消费者等待队列
    private static final Condition notFull = lock.newCondition();   // 生产者等待队列
    private static final LinkedList<Integer> queue = new LinkedList<>();
    private static final int CAPACITY = 5;

    public static void main(String[] args) {
        Thread producer = new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                lock.lock();
                try {
                    while (queue.size() == CAPACITY) {
                        notFull.await(); // 生产者等待队列
                    }
                    queue.add(i);
                    System.out.println("生产者生产：" + i);
                    notEmpty.signal(); // 唤醒一个消费者
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    lock.unlock();
                }
            }
        });

        Thread consumer = new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                lock.lock();
                try {
                    while (queue.isEmpty()) {
                        notEmpty.await(); // 消费者等待队列
                    }
                    int item = queue.removeFirst();
                    System.out.println("消费者消费：" + item);
                    notFull.signal(); // 唤醒一个生产者
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    lock.unlock();
                }
            }
        });

        producer.start();
        consumer.start();
    }
}
```

### **示例解析**
- `notFull` 条件变量用于 **生产者等待队列**（如果队列满了，生产者等待）。
- `notEmpty` 条件变量用于 **消费者等待队列**（如果队列为空，消费者等待）。
- `await()` 使当前线程 **释放锁** 并进入相应的等待队列，直到 `signal()` 唤醒。
- `signal()` 只唤醒一个等待的线程，避免 `notifyAll()` 造成的无效唤醒问题。