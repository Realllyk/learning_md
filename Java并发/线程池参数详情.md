# Java 线程池参数与工作原理学习笔记

## 1. 线程池核心参数

### 1.1 corePoolSize（核心线程数）
- 线程池中常驻的线程数量。
- 即使空闲也不会销毁（除非设置了 `allowCoreThreadTimeOut`）。
- 保证随时有线程可用，减少频繁创建销毁的开销。

### 1.2 maximumPoolSize（最大线程数）
- 线程池能创建的最大线程数。
- 当任务队列已满且核心线程都在忙碌时，会创建非核心线程，直到达到该值。

### 1.3 keepAliveTime（线程存活时间）
- 非核心线程的空闲存活时间，超过后会被销毁。
- 如果设置 `allowCoreThreadTimeOut(true)`，核心线程也会受影响。

### 1.4 unit（时间单位）
- `keepAliveTime` 的时间单位，如秒、毫秒。

### 1.5 workQueue（任务队列）
- 保存等待执行任务的队列，不同实现适用不同场景：
  - **ArrayBlockingQueue**：基于数组，有界 FIFO 队列。适合任务量可预估场景。
  - **LinkedBlockingQueue**：默认无界链表队列。若容量过大，可能导致 OOM。
  - **SynchronousQueue**：不存储任务，直接交给线程。适合高并发、短任务场景。
  - **PriorityBlockingQueue**：按优先级调度，适合需要任务优先级的场景。

### 1.6 threadFactory（线程工厂）
- 控制线程的创建方式，例如线程名称、是否为守护线程。
- 方便日志排查和线程监控。

### 1.7 handler（拒绝策略）
当线程数达到 `maximumPoolSize` 且队列已满时，任务的处理方式：
- **AbortPolicy**：抛出异常（默认）。
- **CallerRunsPolicy**：由提交任务的线程执行任务。
- **DiscardPolicy**：直接丢弃任务。
- **DiscardOldestPolicy**：丢弃队列中最旧任务，再尝试提交。

---

## 2. workQueue 对比分析

| 队列类型 | 是否有界 | 特点 | 线程池扩容行为 |
|----------|----------|------|----------------|
| ArrayBlockingQueue | 有界 | 基于数组，FIFO，容量固定 | 队列满时触发新线程创建，直到最大线程数 |
| LinkedBlockingQueue (默认) | 无界 | 基于链表，容量为 Integer.MAX_VALUE | 任务几乎总能排队，**非核心线程几乎不会创建** |
| LinkedBlockingQueue (指定容量) | 有界 | 可控制任务堆积 | 队列满后才扩容，避免 OOM |
| SynchronousQueue | 无界（零容量） | 不存储任务，直接交给线程 | 每个任务都要线程处理，最大化并行度 |
| PriorityBlockingQueue | 可设容量 | 按优先级执行任务 | 根据优先级调度，而不是 FIFO |

### 为什么高吞吐量时使用 SynchronousQueue？
- 它不存储任务，避免了队列堆积带来的等待和上下文切换。
- 任务直接交给线程执行，若无空闲线程则创建新线程（直到 `maximumPoolSize`）。
- 适合短平快的任务，如 RPC 调用、HTTP 请求。

---

## 3. LinkedBlockingQueue 的影响

- **默认无界**：`Integer.MAX_VALUE` 容量，任务几乎总能入队。
- **结果**：
  - `maximumPoolSize` 形同虚设，线程数固定在 `corePoolSize`。
  - 可能造成任务无限堆积，导致内存溢出。

👉 建议：使用 `new LinkedBlockingQueue<>(capacity)` 指定容量，避免无限堆积。

---

## 4. threadFactory 使用示例

```java
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.atomic.AtomicInteger;

public class CustomThreadFactory implements ThreadFactory {
    private final AtomicInteger threadNumber = new AtomicInteger(1);
    private final String namePrefix;

    public CustomThreadFactory(String poolName) {
        this.namePrefix = poolName + "-thread-";
    }

    @Override
    public Thread newThread(Runnable r) {
        Thread t = new Thread(r, namePrefix + threadNumber.getAndIncrement());
        t.setDaemon(false); // 是否守护线程
        t.setPriority(Thread.NORM_PRIORITY); // 优先级
        return t;
    }
}
```

使用：
```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    2,
    5,
    60,
    TimeUnit.SECONDS,
    new SynchronousQueue<>(),
    new CustomThreadFactory("MyPool")
);
```

线程名将为：`MyPool-thread-1`, `MyPool-thread-2` …

---

## 5. 参数设置经验

1. **核心线程数 (corePoolSize)**  
   - CPU 密集型任务：`CPU 核数 + 1`  
   - IO 密集型任务：`CPU 核数 × 2` 或更多  

2. **最大线程数 (maximumPoolSize)**  
   - 高并发短任务：可设大一些  
   - 长耗时任务：避免过大，减少切换开销  

3. **任务队列 (workQueue)**  
   - 建议有界（如 ArrayBlockingQueue / LinkedBlockingQueue with capacity）  
   - 否则可能 OOM  

4. **线程存活时间 (keepAliveTime)**  
   - 一般 30s - 60s  

5. **拒绝策略 (handler)**  
   - 强调可靠性：用 `CallerRunsPolicy`  
   - 可容忍丢弃：用 `DiscardOldestPolicy`  

---

## 总结

- **无界队列 (LinkedBlockingQueue 默认)**：线程数固定在 corePoolSize，风险是任务堆积。  
- **有界队列**：结合 maximumPoolSize，能有效削峰填谷。  
- **SynchronousQueue**：适合高并发短任务，任务直接交给线程，不排队。  
- **threadFactory**：用于定制线程名称和属性，便于运维与监控。

