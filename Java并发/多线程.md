
## Java里面的线程和操作系统的线程一样吗？
Java底层会调用`pthread_create`来创建线程，所以本质上java程序创建的线程，就是和操作系统线程是一样的，是1对1地线程模式
![[threads_sys.png]]


---


## Java 线程安全的三大体现

Java 的线程安全主要体现在以下三个方面：
- **原子性**：提供互斥访问，同一时刻只能有一个线程对数据进行操作。在 Java 中使用了 **atomic 包**（该包提供了一些支持原子操作的类，这些类可以在多线程环境下保证操作的原子性）和 **synchronized 关键字** 来确保原子性。
- **可见性**：一个线程对其内存的修改可以及时地被其他线程看到。在 Java 中使用了 **synchronized** 和 **volatile** 这两个关键字来确保可见性。
- **有序性**：一个线程观察其他线程中的指令执行顺序，由于**指令重排**，该观察结果一般是无序的。在 Java 中使用了 **happens-before 原则** 来确保有序性。


---

## 线程的创建方法

### 1. 继承`Thread类`

最直接的方法，用户自定义类继承`java.lang.Thread`类，重写其`run()`方法。其中`run()`方法定义了线程执行的具体任务。创建该类的实例后，通过调用`start()`方法启动线程。

```java
class MyThread extends Thread {
    @Override
    public void run() {
        // 线程执行的代码
    }
}

public static void main(String[] args) {
    MyThread t = new MyThread
    t.start(); 
}
```

 采用继承 Thread 类方式
- **优点**：编写简单，如果需要访问当前线程，无需使用 `Thread.currentThread()` 方法，直接使用 `this`，即可获得当前线程。
- **缺点**：因为线程类已经继承了 `Thread` 类，<span style="color: red;">所以不能再继承其他的父类</span>。


### 2. 实现 `Runnable` 接口 

如果一个类已经继承了其他类，就不能再继承 `Thread` 类，此时可以实现 `java.lang.Runnable` 接口。实现 `Runnable` 接口需要重写 `run()` 方法，<span style="color: blue;">然后将此</span> `Runnable` <span style="color: blue;">对象作为参数传递给 `Thread` 类的构造器</span>，创建 `Thread` 对象后调用其 `start()` 方法启动线程。 

```java
class MyRunnable implements Runnable {
    @Override
    public void run() {
        // 线程执行的代码
    }
}

public static void main(String[] args) {
    Thread t = new Thread(new MyRunnable());
    t.start();
}
```

#### 采用实现 Runnable 接口方式：
- **优点**：
    - 线程类只是实现了 `Runnable` 接口，还可以继承其他的类。
    - 在这种方式下，可以多个线程共享同一个目标对象，所以推荐当多个相同线程来处理同一份资源的情况，从而可以将 CPU 代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。
        
- **缺点**：
    - 编程略复杂。
    - 如果需要访问当前线程，必须使用 `Thread.currentThread()` 方法。


### 3. 实现 Callable 接口与 FutureTask
`java.util.concurrent.Callable` 接口类似于 `Runnable`，但 `Callable` 的 `call()` 方法<span style="color: blue;">可以有返回值并可以抛出异常</span>。要执行 `Callable` 任务，<span style="color: blue;">需将它包装进一个 `FutureTask`</span>，因为 `Thread` 类的构造器只接受 `Runnable` 参数，而 `FutureTask` 实现了 `Runnable` 接口。

``` java
class MyCallable implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        // 线程执行的代码，返回一个整型结果
        return 1;
    }
}

public static void main(String[] args) {
    MyCallable task = new MyCallable();
    FutureTask<Integer> futureTask = new FutureTask<>(task);
    Thread t = new Thread(futureTask);
    t.start();

    try {
        Integer result = futureTask.get(); // 获取线程执行结果
        System.out.println("Result: " + result);
    } catch (InterruptedException | ExecutionException e) {
        e.printStackTrace();
    }
}
```

#### 采用实现 Callable 接口方式：

- **缺点**：
    - 编程略复杂，如果需要访问当前线程，必须调用 `Thread.currentThread()` 方法。
- **优点**：
    - 线程类仅实现 `Runnable` 或 `Callable` 接口，还可以继承其他类。
    - 这种方式下，多个线程可以共享同一个 `target`对象，非常适合多线程处理同一份资源的情况。

### 4. 使用线程池 (实现 Executor 框架)

从 Java 5 开始引入的 `java.util.concurrent.ExecutorService` 和相关类提供了线程池的支持，这是一种更高效的线程管理方式，避免了频繁创建和销毁线程的手动操作。可以通过 `Executors` 类的静态方法创建不同类型的线程池。

```java
class Task implements Runnable {
    @Override
    public void run() {
        // 线程执行的代码
    }
}

public static void main(String[] args) {
    ExecutorService executor = Executors.newFixedThreadPool(10); // 创建固定大小的线程池
    
    for (int i = 0; i < 100; i++) {
        executor.submit(new Task()); // 提交任务到线程池执行
    }
    
    executor.shutdown(); // 关闭线程池
}
```

### 采用线程池方式：

- **缺点**：
    - 线程池增加了程序的复杂性，特别是当涉及线程池参数调整和故障排查时，错误的配置可能导致死锁、资源老化等问题，这些问题的诊断和修复可能会比较复杂。
- **优点**：
    - 线程池<span style="color: blue;">可以重复利用已创建的线程</span>，避免了线程创建和销毁的手动操作，大量提高了程序的效率。
    - 对于<span style="color: blue;">需要运行大量短任务的场景</span>，线程池可以通过处理浮动任务的方式，充分利用存在的线程，减少待消耗时间。
    - 线程池能够高效管理线程的创建和完成，防止因为创建过多线程导致的资源老化 (如内存泄漏)。通过合理配置线程池大小，可以最大化 CPU 利用空间和系统吐吐量。

### 解释
1. **“线程池可以重复利用已创建的线程，避免了线程创建和销毁的手动操作”**：
    - **传统方式**：如果不使用线程池，每次执行一个任务都需要创建一个新的线程 (`new Thread().start()`)，任务完成后线程被销毁。如果任务数量很大，频繁创建和销毁线程会带来性能开销，如线程调度、资源释放等。
    - **线程池优化**：线程池会提前创建一定数量的线程，并在执行完一个任务后不销毁，而是将线程归还到线程池，等待下一个任务使用。这样减少了线程创建和销毁的开销，提高了系统效率。
2. **“对于需要运行大量短任务的场景，线程池可以通过处理浮动任务的方式”**：
	- **短任务的特点**：执行时间短，创建一个新线程的时间成本可能比任务本身的执行时间还长，导致不必要的时间浪费。
	- **线程池优化**：在短任务的情况下，线程池可以复用空闲线程来处理新的任务，而不是为每个任务创建新的线程。这样可以避免线程频繁启动和销毁的开销，使得 CPU 可以更高效地执行任务，而不是浪费时间在线程管理上。


---

## 线程相关方法的分类

### **静态方法（作用于当前线程）**

|方法名|作用|
|---|---|
|`Thread.sleep()`|让 **当前线程** 休眠一段时间|

### **实例方法（作用于特定** `Thread` **对象）**

| 方法名           | 作用                                               |
| ------------- | ------------------------------------------------ |
| `start()`     | 启动线程，让线程进入就绪状态，等待 CPU 调度                         |
| `interrupt()` | 设置线程的中断标志，通知线程需要中断                               |
| `join()`      | 让 **当前线程** 等待另一个线程执行完成                           |
| `wait()`      | 让 **调用该方法的对象** 进入等待状态（必须在 `synchronized` 代码块中调用） |

### **说明**：

- `Thread.sleep()` 是静态方法，直接作用于 **当前线程**，而不是特定 `Thread` 对象。
- `start()`、`interrupt()`、`join()` 和 `wait()` 是实例方法，必须通过 `Thread` 实例调用。



---


## 何时调用`interrupt()`会抛出异常

<span style="color: blue;">每个线程都有一个与之关联的布尔属性来表示其中断状态</span>，中断状态的初始值为 `false`，当一个线程被其他线程调用 `Thread.interrupt()` 方法中断时，会根据实际情况做出响应。

- **如果该线程正在执行低级别的可中断方法** (如 `Thread.sleep()` 、 `Thread.join()` 或 `Object.wait()` )，则会解除阻塞并抛出 `InterruptedException` 异常。
- **否则** `Thread.interrupt()` 仅设置线程的中断状态，在该被中断的线程中稍后可通过轮询中断状态来决定是否要停止当前正在执行的任务。

### **级别的可中断方法抛出异常**

在 Java 线程中，有些操作是可中断的，如 `Thread.sleep()` 、`Thread.join()` 和 `Object.wait()` 等阻塞方法。当该线程被调用 `interrupt()` 时，如果它正在运行这些方法，会立即被中断，同时会抛出 `InterruptedException`，提醒线程可能需要重新处理任务。

#### **示例**：

```java
class MyThread extends Thread {
    @Override
    public void run() {
        try {
            System.out.println("线程将睡眠 5 秒...");
            Thread.sleep(5000); // 该线程被中断时，会抛出 InterruptedException
        } catch (InterruptedException e) {
            System.out.println("线程被中断！");
        }
    }
}

public class InterruptExample {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.start();
        try {
            Thread.sleep(2000); // 为了确保线程已经启动
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        t.interrupt(); // 将线程中断
    }
}
```

#### **进程规律**：

1. 主线程启动 `MyThread` 线程，它会调用 `Thread.sleep(5000)`，从而进入阻塞状态。
2. 主线程休眠 2 秒后将 `MyThread` 中断。
3. `MyThread` 正在 `sleep()`，因此解除阻塞并抛出 `InterruptedException` ，该异常被捕获，线程中断。

### **结论**：
当线程在执行可中断操作时，调用 `interrupt()` 会解除阻塞并抛出 `InterruptedException`，通过捕获该异常，线程可以根据需要选择中断运行或重新处理任务。


---

