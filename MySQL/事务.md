
## 事务的特性是什么？如何实现的？

- **原子性（Atomicity）**：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。而且事务在执行过程中发生错误，会被回滚到事务开始的状态，就像这个事务从未执行过一样。例如，购买一件商品，购买成功时，商家会收到付款，商品到手；如果购买失败，则商品依然属于商家，付款金额也会回滚。
- **一致性（Consistency）**：指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。例如，用户 A 和用户 B 在银行账户中分别有 800 元和 600 元，总共 1400 元。用户 A 转账 200 元给用户 B，需要分两步完成：
    - 用户 A 账户扣除 200 元；
    - 用户 B 账户增加 200 元。
    - 一致性要求上述两个步骤作为一个整体执行，最终数据库中的数据仍保持一致，即 A 账户余额 600 元，B 账户余额 800 元，总额仍为 1400 元。
- **隔离性（Isolation）**：数据库允许多个事务同时对数据进行读写修改，隔离性可以防止多个事务交叉执行时导致数据不一致。即多个事务并发执行时不会互相干扰，每个事务有一个完整的数据库视图，对其他事务是隔离的。例如，某用户购买商品的事务不会影响其他用户的交易。
- **持久性（Durability）**：事务处理结束后，对数据的修改会永久生效，即使系统故障也不会丢失。

### MySQL InnoDB 如何保证事务的 ACID 特性？
- **持久性** 通过 `redo log`（重做日志）保证。
- **原子性** 通过 `undo log`（回滚日志）保证。
- **隔离性** 通过 `MVCC`（多版本并发控制）或锁机制保证。
- **一致性** 通过 `持久性+原子性+隔离性` 共同保证。


---


## Mysql 设置了可重复读隔离级别后，怎么保证不发生幻读？

**尽量在开启事务之后，马上执行** `select ... for update` **这类锁定读的语句**，因为它会对记录加 `next-key lock`，从而避免其他事务插入一条新记录，就避免了幻读的问题。


---


## 串行化隔离级别是通过什么实现的？

是通过**行级锁**来实现的，串行化隔离级别下，普通的 `select` 查询是会对记录加 S 型的 `next-key` 锁，其他事务就没办法对这些已经加锁的记录进行增删改操作了，从而避免了脏读、不可重复读和幻读现象。


---


## 介绍MVCC实现原理

MVCC允许多个事务同时读取同一行数据，而不会彼此阻塞，每个事务看到的数据版本是该事务开始时的数据版本。这意味着，如果某个事务在此期间修改了数据，正在运行的事务仍然看到的是它开始时的数据状态，从而实现了非阻塞读操作。

对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同。大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。

- **「读提交」隔离级别是在「每个`select`语句执行前」都会重新生成一个 Read View；
- **「可重复读」隔离级别是在「执行第一条`select`时」生成一个 Read View，然后整个事务期间都在用这个 Read View。

![[read_view.png]]

### Read View 相关参数
- **m_ids**：指的是在创建 Read View 时，当前数据库中「活跃事务」的事务 id 列表，注意是一个列表，「活跃事务」指的是**启动了但还没提交的事务**。
- **min_trx_id**：指的是在创建 Read View 时，当前数据库中「活跃事务」中的事务 id **最小的事务**，也就是`m_ids`的最小值。
- **max_trx_id**：这个并不是`m_ids`的最大值，而是**创建 Read View 时当前数据库中应该给下一个事务的 id 值**，也就是全局事务中**最大的事务 id 值 +1**。
- **creator_trx_id**：指的是**创建该 Read View 的事务 id**。

### InnoDB 存储引擎的隐含列
![[InnoDB_聚簇索引_隐藏列.webp]]
对于使用 InnoDB 存储引擎的数据库表，它的聚簇索引记录中包含下面两个隐藏列：
- **trx_id**：当一个事务对某条聚簇索引记录进行改动时，**就会把该事务的事务 id 记录在**`trx_id`**隐藏列里**。
- **roll_pointer**：每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后**这个隐藏列是一个指针，指向每一个旧版本记录**，于是就可以通过它找到修改前的记录。

### 事务访问记录的可见性
在创建 Read View 后，我们可以将记录中的`trx_id`划分这三种情况：
一个事务去访问记录时，除了自己的更新记录总是可见的之外，还会有几种情况：
- **如果记录的**`trx_id`**小于 Read View 中的**`min_trx_id`**值**，表示这个版本的记录是在创建 Read View **前**已经提交的事务生成的，所以该版本的记录**对当前事务可见**。
- **如果记录的**`trx_id`**大于等于 Read View 中的**`max_trx_id`**值**，表示这个版本的记录是在创建 Read View **后**才启动的事务生成的，所以该版本的记录**对当前事务不可见**。
- **如果记录的**`trx_id`**值在 Read View 的**`min_trx_id`**和**`max_trx_id`**之间**，需要判断`trx_id`是否在`m_ids`列表中：
    - 如果`trx_id`**在**`m_ids`**列表中**，表示生成该版本记录的**事务仍然是活跃的（还没提交事务）**，所以该版本的记录**对当前事务不可见**。
    - 如果`trx_id`**不在**`m_ids`**列表中**，表示生成该版本记录的**活跃事务已经被提交**，所以该版本的记录**对当前事务可见**。

这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫做 **MVCC（多版本并发控制）**。


---
