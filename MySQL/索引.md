
# 索引是什么
索引类似于书籍的目录，可以减少扫描的数据量，提高查询效率。

- 如果查询的时候，没有用到索引就会 **全表扫描**，这时候查询的时间复杂度是 **O(n)**。
- 如果用到了索引，那么查询的时候，可以基于 **二分查找算法**，通过索引快速定位到目标数据。MySQL 索引的数据结构一般是 **B+树**，其搜索复杂度为 **O(logdN)**，其中：
	- `d` 表示 **节点允许的最大子节点个数**;
	- `N` 为数据量大小。


---


## 索引的分类

MySQL 可以按照四个角度来分类索引：

- **按「数据结构」分类**：B+tree 索引、Hash 索引、Full-text 索引。
- **按「物理存储」分类**：聚簇索引（主键索引）、二级索引（辅助索引）。
- **按「字段特性」分类**：主键索引、唯一索引、普通索引、前缀索引。
- **按「字段个数」分类**：单列索引、联合索引。


### **1.按数据结构分类**
从数据结构的角度来看，MySQL 常见索引有<span style="color: blue;"> B+Tree 索引、HASH 索引、Full-Text 索引</span>。

每一种存储引擎支持的索引类型不一定相同，在表中总结了 MySQL 常见的存储引擎 InnoDB、MyISAM 和 Memory 分别支持的索引类型。

InnoDB 是在 MySQL 5.5 之后成为默认的 MySQL 存储引擎，B+Tree 索引类型也是 MySQL 存储引擎采用最多的索引类型。

![[hash_categories_on_data_structure.webp]]

在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：
- 如果有主键，默认会使用主键作为聚簇索引的索引键（key）。
- 如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）。
- 在上面两个都没有的情况下，InnoDB 将<span style="color: blue;">自动生成一个隐式自增 id</span> 列作为聚簇索引的索引键（key）。

其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。
<span style="color: blue;">创建的主键索引和二级索引默认使用的是 B+Tree 索引。</span>


### **2.按物理存储分类**

从物理存储的角度来看，索引分为**聚簇索引（主键索引）**、**二级索引（辅助索引）**。

这两个区别在前面也提到了：
- **主键索引的 B+Tree 的叶子节点存放的是实际数据**，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；
- **二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据**。

因此，在查询时使用二级索引：
- **如果查询的字段能在二级索引里查询到**，那么就不需要回表，这个过程就是**覆盖索引**；
- **如果查询的字段不在二级索引里**，则会先检索二级索引，找到对应的叶子节点，获取到主键值，然后再检索主键索引，就能查询到数据了，这个过程就是**回表**。


### **3.按字段特性分类**

从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引。

#### **主键索引**

主键索引是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。

**创建主键索引的方式如下：**
```mysql
CREATE TABLE table_name (
    ....
    PRIMARY KEY (index_column_1) USING BTREE
);
```

#### **唯一索引**

唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。

**创建唯一索引的方式如下：**
```mysql
CREATE TABLE table_name (
    ....
    UNIQUE KEY(index_column_1, index_column_2,...)
);
```

#### **普通索引**

普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。

**创建普通索引的方式如下：**
```mysql
CREATE TABLE table_name (
    ....
    INDEX(index_column_1, index_column_2,...)
);
```

**或者在表创建后，使用以下命令创建普通索引：**

```mysql
CREATE INDEX index_name
ON table_name(index_column_1, index_column_2,...);
```

#### **前缀索引**
前缀索引是指对字符串字段的前几个字符建立的索引，而不是在整个字段上建立的索引。前缀索引可以建立在字段类型为 char、varchar、binary、varbinary 的列上。

使用前缀索引的目的是为了减少索引占用的存储空间，提高查询效率。

**创建前缀索引的方式如下：**
```mysql
CREATE TABLE table_name(
    column_list,
    INDEX(column_name(length))
);
```

**或者在表创建后，使用以下命令创建前缀索引：**
```mysql
CREATE INDEX index_name
ON table_name(column_name(length));
```


### 4.按字段个数分类

从字段个数的角度来看，索引分为单列索引、联合索引（复合索引）。

- 建立在单列上的索引称为单列索引，比如主键索引；
- 建立在多列上的索引称为联合索引。

通过将多个字段组合成一个索引，该索引就被称为联合索引。

例如，将商品表中的 `product_no` 和 `name` 字段组合成联合索引 `product_no, name`，创建联合索引的方式如下：

```mysql
CREATE INDEX index_product_no_name ON product(product_no, name);
```

联合索引 `(product_no, name)` 的 B+Tree 示意图如下（图中叶子节点之间我画了单向链接表，但是实际上是双向链接表，原图我找不到了，修改也不干了，偷个懒不重画了，大家脑补成双向链接表就行）。
![[union_column_index.png]]

可以看到，联合索引的非叶子节点采用两个字段的值作为 B+Tree 的 key 值。当在联合索引查询数据时，先按 `product_no` 字段比较，在 `product_no` 相同的情况下再按 `name` 字段比较。

也就是说，联合索引查询的 B+Tree 是先按 `product_no` 进行排序，然后再 `product_no` 相同的情况下再按 `name` 字段排序。

因此，使用联合索引时，存在**最左匹配原则**，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循“最左匹配原则”，联合索引会失效，这样就无法利用到索引的快速查询特性了。

例如，如果创建了一个 `(a, b, c)` 联合索引；如果查询条件是以下几种，就可以匹配上联合索引：

- `where a=1;`
- `where a=1 and b=2 and c=3;`
- `where a=1 and b=2;`

需要注意的是，因为有查询优化器，所以 `a` 字段在 `where` 子句的顺序并不重要。

但是，如果查询条件是以下几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引会失效：

- `where b=2;`
- `where c=3;`
- `where b=2 and c=3;`

上面这些查询条件之所以会失效，是因为 `(a, b, c)` 联合索引，是先按 `a` 排序，在 `a` 相同的情况下再按 `b` 排序，在 `b` 相同的情况下再按 `c` 排序。所以，`b` 和 `c` 是全局无序、局部相对有序的，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。

联合索引有一些特殊情况，**并不是查询过程中使用了联合索引查询，就代表联合索引中的所有字段都用到了**。

联合索引进行查询，它就可能存在部分字段用到联合索引的 B+Tree，部分字段没有用到联合索引的 B+Tree 的情况。

这种特殊情况就发生在**范围查询**。联合索引的最左匹配原则**一直向右匹配直到遇到“范围查询”就会停止匹配**。

也就是说，范围查询的字段可以用到联合索引，但是在范围查询字段的后面字段无法用到联合索引。


---


## 聚簇索引与非聚簇索引

![[聚簇_非聚簇.webp]]
### 数据存储
在聚簇索引中，数据行按照索引键值的顺序存储，也就是说，索引的叶子节点包含了实际的数据行。这意味着索引结构本身就是数据的物理存储结构。非聚簇索引的叶子节点不包含完整的数据行，而是包含指向数据行的指针或主键值。数据行本身存储在聚簇索引中。

### 索引与数据关系
由于数据与索引紧密相连，当通过聚簇索引查找数据时，可以**直接从索引中获得数据行**，而不需要额外的步骤去查找数据所在的位置。通过非聚簇索引查找数据时，首先在非聚簇索引中找到对应的主键值，然后通过这个主键值回查聚簇索引中的数据行，这个过程称为**回表**。

### 唯一性
聚簇索引通常是基于主键构建的，因此每张表**只能有一个聚簇索引**，因为数据只能有一种物理排序方式。一个表可以有多个非聚簇索引，因为它们不直接影响数据的物理存储位置。

### 效率
对于**范围查询和排序查询**，聚簇索引通常更有效率，因为它避免了额外的行扫描开销。非聚簇索引在使用覆盖索引进行查询时效率较高，因为它不需要进行额外的回表操作。但是需要进行回表的操作时，使得非聚簇索引的效率比聚簇索引低。


---


## 什么字段适合当做主键？
- 字段具有唯一性，且不能为空的特性。
- 字段最好是有递增的趋势的，如果字段的值是随机无序的，可能会引发分页分裂的问题，造成性能影响。
- 不建议用业务数据作为主键，比如**会员卡号、订单号、学生号**之类的，因为我们无法预测未来会不会因业务需要，而出现业务字段重复或者重新用的情况。
- 通常情况下不会用**自增字段**做主键，对于单机系统来说是没问题的。但是，如果有多台服务器，各自都可以录入数据，那就不太适用了。<span style="color: orange;">因为如果每台机器各自产生的数据需要合并，就可能会出现主键重复的问题</span>，这时候需要考虑**无冲突的方式**的方案。


---


## 为什么自增 ID 更快一些，UUID 不快吗，它在 B+ 树里面存储是有序的吗？

自增的主键的值是顺序的，所以 InnoDB 把每一条记录都存储在一条记录的后面，所以自增 ID 更快的原因：

- 下一条记录就会写入新的页中，一旦数据按照这种顺序的方式加载，主键页就会近乎于顺序的记录填满，提高了页面的最大填充率，不会有页的浪费。
- 新插入的行一定会在原有的最大数据行下一行，MySQL 定位和寻找很快，不会为计算新的位置而做出额外的消耗。
- 减少了页分裂和碎片的产生。

但是 UUID 并不是递增的，MySQL 目录的数据库结构是 B+Tree，这种数据结构的特点是索引树上的叶节点数据是有序的，而如果使用 UUID 作为主键，那么每次插入数据时，因为无法保证每次产生的 UUID 有序，所以就会出现新的 UUID 需要插入到索引树的中间去，这样可能会导致**索引分裂**，使性能下降。

而且，UUID 太大且不紧凑。每个 UUID 由 36 个字符组成，字符串相比数值型较大，需要从前往后比较，字符串越长，性能越差。另外字符串类型比数字类型占用更多的存储空间，由于页的大小是固定的，这样一个页内能存放的索引节点数量就会变少，这样最终就会导致索引的高度变高，在索引搜索时，发生的磁盘 I/O 次数越多，性能越差。


---

## Mysql的索引是怎么实现的

MySQL InnoDB 引擎是用了 B+ 树作为了索引的数据结构。

B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是**按主键顺序存放的**。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包含了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个**双向链表**。

数据库的索引和数据都是存储在硬盘的，我们可以把<span style="color: blue;">读取一个节点当作一次磁盘 I/O 操作</span>。

B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O，所以 **B+Tree 相比于 B 树和二叉树来说，最大优势在于查询效率高**。因为即使在数据量很大的情况下，查询一个数据的磁盘 I/O 依然维持在 3-4 次。


---

## 查询数据时，到了 B+ 树的叶子节点，之后的查找数据是如何做？

### 记录存储结构

**数据页中的记录按「主键」顺序组成单向链表**，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。

因此，数据页中有一个**页目录**，起到记录的索引作用，就像书籍中目录的索引一样，针对书中内容的每个章节设立一个目录，想查看某个章节的时，就可以看目录，快速找到对应的章节的页数，而数据页中的页目录就是为了能快速找到记录。

![[page_directory.webp]]
### 页目录的创建过程
1. **将所有的记录划分成几个组**，这些记录包括<span style="color: blue;">最小记录和最大记录</span>，但不包括标记为“已删除”的记录；
2. **每个记录组的最后一条记录**是该组内最大的那条记录，<span style="color: blue;">并且最后一条记录的头信息中会存储该组一共有多少条记录</span>，作为 `n_owned` 字段；
3. **页目录数组存储每组最后一条记录的地址偏移量**，这些地址偏移量是按顺序存储起来，每组的地址偏移量被称为**槽（slot）**，每个槽指针指向了不同组的最后一条记录。

### 页目录的作用

页目录就是由多个**槽组成的索引**，槽相当于分组记录的索引。因此，我们通过查询记录时，可以**使用二分法**快速定位要查找的记录在**哪个槽（记录分组）**，定位到槽后，再遍历槽内的所有记录，找到对应的记录，而不需要从最小记录开始遍历整个页中的记录链表。

### 示例
假设某页的槽编号为 `0,1,2,3,4,5`，需要查找**主键 11** 的记录，过程如下：
1. **先二分搜索槽**，(0+4)/2 = 2，2 号槽里最大记录为 8，因 11 > 8，需继续在 2 号槽后搜索记录；
2. **再次二分搜索**，(2+4)/2 = 3，3 号槽里最大记录 12，因 11 < 12，确定 11 的记录在 3 号槽；
3. **遍历 3 号槽的记录链**，找到**主键 11**，取出数据。

页目录的设计极大地提高了数据的查询效率，避免了全页扫描，提高索引查找的性能。


---


## B+ 树的特性是什么
- **所有叶子节点都在同一层**：
    - 这保证了所有数据项的检索具有相同的 I/O 延迟，提高了搜索效率。
    - 每个叶子节点都含有相邻叶子节点的指针，形成一个链表，适合范围查询和排序扫描。
- **非叶子节点存储键值**：
    - 只存储键值和指向子节点的指针，不包含数据记录。
    - 这种设计可以减少树的高度，提高查询效率。
- **叶子节点存储数据记录**：
    - 叶子节点包含数据记录或者数据记录的指针。
    - 查询时需要最终找到叶子节点，才能获取数据。
- **自平衡**：
    - 插入和删除操作会自动维持树的平衡，保证树的高度保持稳定，提高查询性能。在 B+ 树中，每个非根节点的子节点数目必须在 $\lceil M/2 \rceil$到$M$之间，其中$M$ 是 B+ 树的阶数。



---


## B+ 树和 B 树的区别

1. **数据存储方式不同**：
    - B 树：所有节点（叶子和非叶子）都存储数据.
    - B+ 树：非叶子节点仅存索引，数据全部存储在叶子节点。
2. **叶子节点结构**：
    - B 树的叶子节点不相连。
    - B+ 树的叶子节点使用链表连接，支持高效的范围查询和顺序访问。
3. **查询性能差异**：
    - B+ 树的查找性能更稳定，每次查询都要到叶子节点。
    - B 树可能在非叶子节点找到数据，导致查询路径不稳定。


---


## MySQL 为什么用 B+ 树结构？和其他结构比的优点？

### B+Tree vs B Tree

**B+Tree 只在叶子节点存储数据，而 B 树的非叶子节点也要存储数据**，所以 B+Tree 的单个节点的数据量更小，<span style="color: blue;">在相同的磁盘 I/O 次数下，能查找更多的节点</span>。此外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。

### B+Tree vs 二叉树

**对于有 N 个叶子节点的 B+Tree，其搜索复杂度为 O($log_{D}N$)，其中 D 表示节点允许的最大子节点个数**。在实际的应用当中（值是大于 100 的），这样就很广，即使数据达到千万级别时，B+Tree 的高度依然维持在 3～4 层左右，也就是说一次数据查询操作仅需经历 3×4 次的磁盘 I/O 操作就能查到目标数据。而二叉树的每个父节点最多有 2 个子点，意味着其搜索复杂度为 O($log_{2}N$)，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。

### B+Tree vs Hash

**Hash 在做等值查询的时候效率最快，搜索复杂度为 O(1)**，但是 <span style="color: blue;">Hash 表不适合做范围查询</span>，它更适合做等值的查询。这也是 B+Tree 索引比 Hash 表索引有着更广泛的适用场景的原因。


---


## 为什么 MySQL 不用跳表？

B+树的高度在 3 层时存储的数据可能已达千万级别，但对于跳表而言，去维护千万级别的数据量会导致跳表层数过高，从而导致磁盘 I/O 读写次数增多。这意味着在存储相同数据的情况下，B+树的磁盘 I/O 次数更少，因此 MySQL 更倾向于使用 B+树。

### 什么是跳表？
跳表（Skip List）是一种基于链表的数据结构，它在普通有序链表的基础上增加了多级索引，使得查找效率可以接近 O(logN)，与平衡树（如 AVL 树、红黑树）类似。跳表的基本思想是通过构建多层索引，允许在较高层级跳跃查找，从而加快查询速度。然而，维护这些索引层级会增加额外的存储开销，并导致插入和删除操作的复杂度上升。在 MySQL 这样的数据库系统中，B+ 树更适合索引管理，因为它在减少磁盘 I/O 方面表现更优。


---


## 创建联合索引时需要注意什么？

建立联合索引时的字段顺序，对索引效率也有很大影响。**越靠前的字段被用于索引过滤的概率越高**，实际开发工作中**建立联合索引时，要把区分度大的字段排在前面**，这样区分度大的字段越有可能被更多的 SQL 使用到。

区分度就是某个字段 column 不同值的个数「除以」表的总行数。

![[distinct.webp]]

比如，性别的区分度就很小，不适合建立索引或不适合排在联合索引列的靠前位置，而 UUID 这类字段就比较适合做索引列排在联合索引列的靠前的位置。

因为如果索引的区分度很小，假设字段的值分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，<span style="color: orange;">因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在数据行中的百分比（常用的百分比阈线是 30%）很高的时候，它一般会忽略索引，进行全表扫描</span>。


---


## 联合索引的使用规则

### 联合索引 ABC，执行语句 `A = XXX AND C < XXX`，索引如何走？
根据最左匹配原则，A 可以走联合索引，C 不会走联合索引，但是 C 可以走索引下推。

### 联合索引 (a, b, c)，查询条件 `WHERE b > XXX AND a = X` 会生效吗？
索引会生效，a 和 b 字段都能利用联合索引，符合联合索引最左匹配原则。

### 联合索引 (a, b, c)，查询条件 `WHERE a = 2 AND c = 1`，能用到联合索引吗？
会用到联合索引，但是只有 a 才能走索引，c 无法走索引，因为不符合最左匹配原则。虽然 c 无法走索引，但是 c 字段在 5.6 版本之后，会有索引下推的优化，能减少回表查询的次数。


### **索引下推（Index Condition Pushdown, ICP）总结**

#### **1. 什么是索引下推？**
索引下推（Index Condition Pushdown, ICP）是一种 MySQL 在 **5.6 版本** 引入的 **查询优化策略**，用于优化带 **范围查询**（如 `BETWEEN`、`>、<、>=、<=`）或 **索引前缀匹配** 的查询，减少回表操作，提高查询效率。

#### **2. 索引下推的工作原理**
在 **MySQL InnoDB 存储引擎** 中，普通查询流程如下：

1. 先通过索引定位到符合**索引字段**的记录。
2. 然后回表（访问主键索引）获取完整的行数据。
3. 最后在 **Server 层** 进行 `WHERE` 条件过滤。

**索引下推的优化方式：**
- 直接在 **索引树** 中对符合条件的索引列进行过滤，减少回表次数。
- 只有**通过索引字段初步筛选后仍符合查询条件的数据**，才需要回表查询完整数据。

#### **3. 索引下推的适用场景**

索引下推优化主要适用于 **复合索引**，尤其是：
- **范围查询（`BETWEEN`、`>`、`<` 等）**
- **前导索引匹配（LIKE 'abc%'）**
- **部分索引列匹配（WHERE a = 1 AND b > 10）**

#### **4. 索引下推的示例**

假设有一个表 `users`：
``` mysql
CREATE TABLE users (     
	id INT PRIMARY KEY,     
	name VARCHAR(50),     
	age INT,     
	city VARCHAR(50),     
	INDEX idx_name_age (name, age) 
);
```


``` mysql
SELECT * FROM users WHERE name LIKE 'A%' AND age > 25;
```

**普通查询流程（无 ICP）：**
- 先通过 `idx_name_age` 定位 `name LIKE 'A%'` 的记录。
- 取出这些记录的 **主键 id**，然后**回表** 获取完整行数据。
- 在 `Server 层` 进一步筛选 `age > 25` 的数据。

**索引下推优化（有 ICP）：**
- 在 `idx_name_age` 复合索引中，直接筛选出符合 `name LIKE 'A%' AND age > 25` 的数据。
- 只对符合 **所有索引条件** 的记录才回表查询，减少不必要的 I/O。

#### **5. 索引下推的优点**
- **减少回表次数**，降低 I/O 负担。
- **提升查询性能**，尤其适用于索引列筛选比例较高的情况。
- **更高效地利用复合索引**，避免服务器端的二次筛选。


---


## 怎么决定建立哪些索引？

### 什么时候适用索引？
- 字段有唯一性限制的，比如商品编码；    
- 经常用于 `WHERE` 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引；
- 经常用于 `GROUP BY` 和 `ORDER BY` 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排好序的。

### 什么时候不需要创建索引？
- `WHERE` 条件、`GROUP BY`、`ORDER BY` 里用不到的字段，索引的价值是快速定位，如果起不到定位的作用，则浪费了物理空间；
- 字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪种性别，都会扫描一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器会发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描；
- 表数据量小的时候，不需要创建索引；
- 变更频繁的字段不创建索引，比如不要对电商项目的余额建立索引，因为索引字段频繁修改，代价较高。


---


## 聚簇索引只能由一个吗？
是的，在 MySQL 中，一个表只能有一个聚簇索引。

### 原因
- **数据存储方式**：聚簇索引决定了表中数据的物理存储顺序，因此一个表只能有一种物理存储方式。
- **主键约束**：通常，主键会自动成为聚簇索引。如果没有主键，MySQL 会选择一个唯一的非空索引作为聚簇索引；若两者都没有，MySQL 会生成一个隐藏的行 ID 作为聚簇索引。

### 其他索引
- **非聚簇索引（二级索引）**：可以有多个，它们存储的是指向聚簇索引的指针，而不是数据本身。
    

### 总结

- **一个表只能有一个聚簇索引**，但可以有多个非聚簇索引。