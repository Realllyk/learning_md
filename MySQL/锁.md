
## mysql中有那些锁

在MySQL里，根据加锁的范围，可以分为<span style="color: blue;">全局锁、表级锁和行锁</span>
![[lock_categories.webp]]
### 全局锁
- 通过 `flush tables with read lock` 语句会将整个数据库设为只读状态，这时其他线程执行插入、删除或者表结构修改都会阻塞。
- 主要用于 **全库逻辑备份**，以确保备份文件数据的一致性。

### 表级锁
- **表锁**：使用 `lock tables` 语句显式加锁，限制读写操作。
- **元数据锁（MDL 锁）**：用于保证表结构变更安全性，在 DDL 变更时加 MDL 写锁，在 CRUD 操作时加 MDL 读锁。
- **意向锁**：用于加快判断是否有记录被加锁，如插入、更新或删除时加意向独占锁。

### 行级锁
- **记录锁**：锁住**一条记录**，读写互斥。有S锁和X锁之分，满足读写互斥、写写互斥
	- **S（共享锁，Shared Lock）**：多个事务可以同时获取 S 锁，用于**读**操作，不影响其他事务的读取，但会阻塞写操作。
	- **X（排他锁，Exclusive Lock）**：只能被一个事务持有，用于**写**操作，阻止其他事务对该记录的任何读写。
- **间隙锁**：锁定的是**索引记录之间的范围**，用于可重复读隔离级别，防止幻读。
- **Next-Key 锁**：记录锁 + 间隙锁，锁住范围并且锁定记录本身。


---


## 间隙锁为什么能够防止幻读？

间隙锁（Gap Lock）是 InnoDB 事务隔离级别 **可重复读（REPEATABLE READ）** 及以上时，为了防止 **幻读（Phantom Read）** 而引入的一种锁机制。
幻读是指在一个事务中多次执行相同的查询时，由于其他事务插入了新的数据，导致查询结果不一致。例如：
1. 事务 A：`SELECT * FROM users WHERE age BETWEEN 10 AND 20;`
2. 事务 B：`INSERT INTO users (age) VALUES (15);`
3. 事务 A：再次执行 `SELECT * FROM users WHERE age BETWEEN 10 AND 20;`，结果集发生变化。

**间隙锁的作用**：
- 当事务 A 读取 `age BETWEEN 10 AND 20` 的数据时，会在 (10,20) 之间加间隙锁，防止事务 B 在这个区间插入新数据。
- 这样，事务 A 在执行相同的查询时，保证了数据一致性，避免了幻读的发生。



---
## next-key lock

**next-key lock** 是 InnoDB 在 **可重复读（REPEATABLE READ）** 及以上隔离级别下，结合 **行锁（Record Lock）** 和 **间隙锁（Gap Lock）** 形成的一种锁机制， 它会锁住索引记录本身以及索引记录之前的间隙。

例如，有如下表数据：

|id|age|
|---|---|
|5|10|
|10|20|
|15|30|
|20|40|

当事务执行 `SELECT * FROM users WHERE age = 20 FOR UPDATE;` 时，**next-key lock** 锁住的范围是 `(10, 20]`，不仅锁住 `age=20`，还锁住 `(10, 20)` 这个间隙。

**next-key lock 作用**：
- 结合了行锁和间隙锁，确保查询范围内不会有新记录插入。
- 防止了 **幻读**，保证数据一致性。
- 主要用于**索引列**，如果是非索引列的查询，可能会退化成 **表锁** 或 **行锁**。


---


## 数据库的表锁和行锁有什么作用？

### 表锁的作用

- **整体控制**：表锁可以用来控制整个表的并发访问，当一个事务获取了表锁时，其他事务无法对该表进行任何读写操作，从而确保数据的完整性和一致性。
- **粒度大**：表锁的粒度比较大，在锁表的情况下，可能会影响到整个表的其他操作，可能会引起锁竞争和性能问题。
- **适用于大批量操作**：表锁适合于需要大批量操作表中数据的场景，例如表的重建、大量数据的加载等。

### 行锁的作用

- **细粒度控制**：行锁可以精确控制对表中某行数据的访问，使得其他事务可以同时访问表中的其他行数据，在并发量大的系统中能提高并发性能。
- **减少锁冲突**：行锁不像表锁那样造成较大的锁冲突，减少了锁竞争的可能性，提高了并发访问的效率。
- **适用于频繁单行操作**：行锁适合于需要频繁对表中单独行进行操作的场景，例如订单系统中的订单修改、删除等操作。


---


## MySQL两个线程的update语句同时处理一条数据，会不会有阻塞？

如果是两个事务同时更新 id = 1，比如 `update ... where id = 1`，那么是会阻塞的。因为 InnoDB 存储引擎实现了行级锁。
当A事务对 id = 1 这行记录进行更新时，会对主键 id 为 1 的记录加X类型的记录锁，这样第二个事务对 id = 1 进行更新时，发现已经有记录锁了，就会陷入阻塞状态。


---


## 两条update语句处理一张表的不同的主键范围的记录，一个<10，一个>15，会不会遇到阻塞？底层是为什么？

不会，因为锁住的范围不一样，不会形成冲突。
- 第一条 update sql 的话（`id<10`），锁住的范围是 (-∞，10)
- 第二条 update sql 的话（`id>15`），锁住的范围是 (15，+∞)


---

## 如果2个范围不是主键或索引？还会阻塞吗？

如果两个范围查询的字段不是索引的话，那就代表 update 没有用到索引，这时候触发了全表扫描，全部索引都会加行级锁，这时候第二条 update 访问的行，就会阻塞了。

因为如果 update 没有用到索引，在扫描过程中会对扫描到的记录加锁，所以全表扫描的场景下，所有记录都会被加锁，也就是这条 update 语句产生了 4~15 个间隙锁，相当于锁住了全表。