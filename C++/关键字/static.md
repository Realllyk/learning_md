# C++ `static` 速查与实践指南

> 一句话：**C++ 的 `static` 一词多义**——在“类内/函数内/文件作用域”分别表示不同语义。正确使用能减少耦合、避免初始化顺序坑，提高可读性与可维护性。

---

## 目录
1. 为什么一个词多义
2. 用法一：类内静态成员（数据/函数）  
3. 用法二：函数内静态局部变量  
4. 用法三：文件/命名空间作用域的 `static`（内部链接）  
5. 静态成员与“本类类型”/指针/引用
6. 模板与 `static`
7. 并发与内存模型要点
8. 初始化顺序（SIOF）与工程级建议
9. 常见误区速查
10. 快速自检清单
11. 参考代码片段

---

## 1) 为什么一个词多义
- **类内**：把成员“提升为**类级别**”，所有对象共享；静态成员函数**无 `this`**。  
- **函数内（块作用域）**：把局部变量改为**静态存储期**（仅初始化一次，跨调用保存状态）。  
- **文件/命名空间作用域**：把实体的**链接性**改为**内部链接**（仅当前翻译单元可见）。

> 牢记：**类内 `static` 是“属于类”**；**文件/命名空间 `static` 是“仅此文件可见”**；**函数内 `static` 是“只初始化一次、终身存活”。**

---

## 2) 用法一：类内静态成员（数据/函数）

### 2.1 静态数据成员
- 所有对象共享**一份**；**不占用**每个对象的内存布局。
- 一般需**类外定义**（分配存储）；C++17 起可用 `inline` 变量避免 ODR 多重定义问题。

```cpp
struct Counter {
    static inline std::atomic<int> total{0};  // C++17 起：类内定义 + 内联存储
    static int legacy;                        // 仅声明，需类外定义
};
int Counter::legacy = 0;                      // 旧写法的类外定义
```

- **整型常量优化**：`static const int N = 16;` 可在类内定义且作为编译期常量使用；若需**取地址**仍要类外定义。  
- `static constexpr`（C++11+）可类内定义并当常量表达式使用。

### 2.2 静态成员函数
- **无 `this`** → 不能**直接**访问非静态成员；可通过**对象/指针/引用**访问。  
- 不能是 `virtual`；可有 `private/protected/public` 限定。

```cpp
struct A {
    static int s; int x;
    static void f(A& a) { s++; a.x++; }  // 通过对象访问实例成员
};
int A::s = 0;
```

### 2.3 访问控制与依赖
- 可访问**同类**的私有静态成员（受访问控制修饰符限制）。
- 与模板、内联、友元等配合要注意 ODR（单一定义规则）。

---

## 3) 用法二：函数内静态局部变量（“魔法静态”）

- **首次调用时**初始化（惰性初始化）；自 C++11 起**初始化线程安全**。  
- 之后每次调用复用同一对象，生命周期至程序结束。

```cpp
int next_id() {
    static int id = 0;  // 初始化一次
    return id++;
}
```

**典型场景**：Meyers 单例、缓存对象、统计计数、延迟构造昂贵资源等。

**注意**：静态对象的析构发生在程序结束阶段；在复杂系统里可考虑“**不析构**”以避免退出序析构顺序问题。

---

## 4) 用法三：文件/命名空间作用域的 `static`（内部链接）

- 让变量/函数**仅在本翻译单元可见**，避免符号外泄与命名冲突：

```cpp
// foo.cpp
static void helper();   // 仅 foo.cpp 内可见
static int cache = 0;   // 仅 foo.cpp 内可见
```

- **推荐替代**：**匿名命名空间**（等价内部链接，更符合现代风格）：

```cpp
namespace {              // 仅当前翻译单元
int cache = 0;
void helper() {}
}
```

- **头文件陷阱**：在头文件里写 `static int x = 0;` 会导致**每个包含它的 .cpp 各有一份**（往往不是你想要的）。若需要共享一份：
  - 在头文件里**声明**：`extern int x;`，在某个 `.cpp` **定义**：`int x = 0;`；或
  - C++17 起使用 `inline` 变量：`inline int x = 0;`（头文件定义、全工程共享一份）。

---

## 5) 静态成员与“本类类型”/指针/引用

- **非静态**数据成员**不能**直接是“本类类型”的对象（会导致无限递归，类型不完整）。  
- **可以**是**指针/引用**，因为它们大小固定，与被指向类型无关。  
- **静态数据成员**不在对象布局内，因此**可以**是本类类型：

```cpp
struct Node {
    static Node root;  // OK（类外再定义）
    Node* next;        // OK
    // Node self;      // 不行：incomplete type / 无限递归
};
Node Node::root{};     // 类外定义
```

---

## 6) 模板与 `static`

- **类模板的静态数据成员**：**每个特化**各有一份。  
- **函数模板中函数内静态**：**每个实例化**各有一份。  
- 若把**静态数据成员定义**放在头文件，务必：
  - C++17 起使用 `inline`：`template<class T> inline T X<T>::value = ...;`  
  - 或旧写法在某个 `.cpp` 专门**提供定义**，避免多重定义。

---

## 7) 并发与内存模型要点

- 函数内静态的**初始化**是**一次且线程安全**（C++11+），但**对象内部读写**不保证并发安全。  
- 多线程共享的静态变量需要 `std::atomic`、互斥量或更高级同步手段。  
- 注意**发布/可见性**：即使只有一次初始化，也要确保读线程在逻辑上“看到”初始化完成（调用点自然满足；更复杂情境用同步原语）。

---

## 8) 初始化顺序（SIOF）与工程级建议

- **SIOF（Static Initialization Order Fiasco）**：**跨翻译单元**的静态对象**初始化顺序不确定**，若彼此依赖会触发未初始化访问。  
- **建议**：
  1. 通过**函数内静态**惰性创建（Meyers 单例/工厂）。  
  2. 需要“全工程只有一份”的常量/配置，优先用 **`inline` 变量（C++17+）**。  
  3. 避免静态对象的析构副作用（必要时使用 `new` + 不析构，或 `atexit` 控制）。

---

## 9) 常见误区速查

- “静态函数**只能**访问静态变量” ❌  
  - 类内静态函数**不能直接**访问实例成员，但**可以通过对象**访问；文件作用域 `static` 仅限可见性，不限访问内容。

- “把 `static` 当作 Java 的 class-level 语义” ❌  
  - 仅在**类内**类似；**文件/函数层面**语义完全不同（内部链接/静态存储期）。

- “在头文件里随手写 `static` 变量就是共享一份” ❌  
  - 实际是**每个 .cpp 一份**；若要一份，改 `inline` 变量或 `extern`+单一定义。

- “静态成员放本类对象没问题” ❌  
  - **非静态成员**不行；**静态成员**可以（类外定义）。

- “静态初始化天然线程安全” ⭕/❌  
  - **只有函数内静态的初始化**是线程安全；**其他静态对象**并不保证并发访问安全。

---

## 10) 快速自检清单

- [ ] 我需要“类级共享状态/工具函数” → 用**类内 `static`**（C++17+ 尽量 `inline`）。  
- [ ] 我需要“只初始化一次且延迟创建” → 用**函数内静态**。  
- [ ] 我需要“仅本文件可见的辅助符号” → 用**匿名命名空间**（或文件作用域 `static`）。  
- [ ] 这是**头文件**吗？若定义了静态对象：  
  - [ ] 是否用 **`inline` 变量**？否则会不会 ODR 冲突或“一文件一份”？  
- [ ] 是否可能遭遇 **SIOF**？能否改为**惰性初始化**？  
- [ ] 多线程会读写它吗？是否用了 **`std::atomic`/锁**？  
- [ ] 类的静态成员是否需要**类外定义**（非 `inline/constexpr` 的旧写法）？

---

## 11) 参考代码片段

### 11.1 Meyers 单例（线程安全惰性初始化）
```cpp
class Config {
public:
    static Config& instance() {
        static Config inst;    // 首次调用时构造；线程安全（C++11+）
        return inst;
    }
    int port() const { return port_; }
private:
    int port_ = 8080;
    Config() = default;
    // 禁止拷贝/赋值
    Config(const Config&) = delete;
    Config& operator=(const Config&) = delete;
};
```

### 11.2 头文件中共享常量（C++17+）
```cpp
// constants.h
#pragma once
#include <chrono>

inline constexpr int kMaxRetry = 5;                 // 编译期常量
inline const std::chrono::seconds kTimeout{10};    // 运行期常量，但全工程一份
```

### 11.3 文件私有工具（匿名命名空间）
```cpp
// worker.cpp
namespace {
void log_impl(const std::string& msg) { /* ... */ }
int local_counter = 0;
}
void do_work() {
    log_impl("start");
    ++local_counter;
}
```

---

> 结论：把 `static` 当作**三把工具**：  
> ① **类级共享**（静态成员/函数），② **延迟一次**（函数内静态），③ **仅此文件**（内部链接）。  
> 配合 C++17 的 **`inline` 变量/`constexpr`** 与匿名命名空间，可显著降低 ODR 与初始化顺序风险。
