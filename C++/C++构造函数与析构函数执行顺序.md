# C++ 继承对象的构造与析构顺序总结

本文梳理了 C++ 中派生类对象在 **构造** 与 **析构** 时的执行顺序，帮助理解类对象的生命周期。

---

## 1. 构造函数的执行顺序

当创建派生类对象时，执行顺序如下：

1. **基类构造函数**  
   - 按照 **继承声明的顺序** 依次调用。  
   - 与初始化列表中顺序无关。  

2. **成员对象构造函数**  
   - 按照 **成员在类中声明的顺序** 依次调用。  
   - 与初始化列表中书写顺序无关。  

3. **派生类自身的构造函数体**  
   - 最后执行派生类构造函数体内的代码。  

### 示例
```cpp
class B { public: B() { cout << "B 构造" << endl; } };
class C { public: C() { cout << "C 构造" << endl; } };

class A : public B {
    C c;
public:
    A() { cout << "A 构造" << endl; }
};

// 输出：
// B 构造
// C 构造
// A 构造
```

---

## 2. 析构函数的执行顺序

当销毁派生类对象时，执行顺序与构造相反：

1. **派生类自身的析构函数体**  
   - 先清理派生类引入的资源。  

2. **成员对象的析构函数**  
   - 按照 **声明顺序的逆序** 依次调用。  

3. **基类的析构函数**  
   - 按照 **继承声明的逆序** 依次调用。  

### 示例
```cpp
class B { public: ~B() { cout << "B 析构" << endl; } };
class C { public: ~C() { cout << "C 析构" << endl; } };

class A : public B {
    C c;
public:
    ~A() { cout << "A 析构" << endl; }
};

// 输出：
// A 析构
// C 析构
// B 析构
```

---

## 3. 构造与析构顺序对比表

| 阶段     | 顺序 | 构造 | 析构 |
|----------|------|------|------|
| 基类部分 | 1    | 按继承声明顺序调用 | 按继承声明逆序调用 |
| 成员部分 | 2    | 按成员声明顺序调用 | 按成员声明逆序调用 |
| 派生类   | 3    | 最后执行构造函数体 | 最先执行析构函数体 |

---

## 4. 关键点总结
- **构造顺序**：基类 → 成员对象 → 派生类  
- **析构顺序**：派生类 → 成员对象（逆序） → 基类（逆序）  
- 析构顺序完全是构造顺序的反向，保证资源在销毁时的安全性。  

