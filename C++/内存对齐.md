# C++ 结构体内存对齐总结

## 一、为什么要有内存对齐
- CPU 在访问内存时，通常要求数据地址满足特定的对齐条件（如 int 在 4 的倍数地址，double 在 8 的倍数地址）。
- 这样可以在一次总线周期内完成数据访问，避免跨界访问，提升效率。
- 某些架构（如老 ARM/MIPS）如果不对齐，还会触发总线错误。

---

## 二、几个关键概念

1. **自然对齐（natural alignment）**
   - 每个基本类型都有一个“天然”的对齐数，一般等于它的大小。
   - 例如：
     - char 占 1 字节 → 对齐数 1
     - short 占 2 字节 → 对齐数 2
     - int / float 占 4 字节 → 对齐数 4
     - double 占 8 字节 → 对齐数 8

2. **编译器最大对齐上限**
   - 不同平台/编译器会规定一个最大对齐数：
     - GCC/Clang：32 位上限为 4，64 位上限为 8
     - MSVC：统一上限为 8
   - 成员的实际对齐数 = `min(自然对齐, 编译器上限)`。

3. **结构体对齐数**
   - 等于其所有成员“实际对齐数”的最大值。

4. **结构体大小**
   - 必须是“结构体对齐数”的整数倍。
   - 这样可以保证在数组中每个结构体元素都能满足对齐要求。

---

## 三、结构体对齐规则

1. 每个成员在结构体中的偏移量必须是其对齐数的整数倍。
2. 结构体整体的大小必须是其最大对齐数的整数倍。
3. 如果最后一个成员结束时没有对齐，就需要补齐（padding）。

公式：
```
member_align = min(sizeof(type), compiler_max_align)
struct_align = max(all member_aligns)
sizeof(struct) 向上取整到 struct_align 的倍数
```

---

## 四、例子说明

### 例子 1：无 double 成员
```cpp
struct Example {
    char a;   // 1
    int b;    // 4
    short c;  // 2
};
```
- a 在偏移 0，占 1
- b 需要 4 对齐 → 放在偏移 4~7
- c 需要 2 对齐 → 放在偏移 8~9
- 最大对齐数 = 4
- sizeof(Example) = 12（补齐到 4 的倍数）

### 例子 2：含 double 成员
```cpp
struct Test {
    char a;   // 1
    double b; // 8
    int c;    // 4
};
```
- 在 64 位或 MSVC（上限 8）：
  - a 在 0
  - b 需要 8 对齐 → 偏移 8~15
  - c 需要 4 对齐 → 偏移 16~19
  - 最大对齐数 = 8
  - sizeof(Test) = 24

- 在 32 位 GCC/Clang（上限 4）：
  - a 在 0
  - b 退化为 4 对齐 → 偏移 4~11
  - c 在偏移 12~15
  - 最大对齐数 = 4
  - sizeof(Test) = 16

---

## 五、为什么结构体大小要补齐到最大对齐数的倍数

假设：
```cpp
struct S {
    char a;
    double b;
};
S arr[2];
```
- 如果 sizeof(S) = 9（未补齐），那么 arr[1].b 的起始地址不是 8 的倍数，访问会出错或性能严重下降。
- 所以 sizeof(S) 必须补齐到 16，保证数组中每个元素都满足对齐。

---

## 六、调整对齐的方法

1. **#pragma pack(n)**
   - 指定最大对齐上限。
   ```cpp
   #pragma pack(1)
   struct C {
       char a;
       int b;
   };
   #pragma pack()
   ```

2. **alignas**（C++11 及以后）
   - 强制指定某个成员或结构体的对齐。
   ```cpp
   struct alignas(16) Vec4 {
       float x, y, z, w;
   };
   ```

---

# ✅ 总结
- 成员对齐 = min(类型大小, 编译器最大对齐)  
- 结构体对齐 = 所有成员实际对齐数的最大值  
- 结构体大小 = 向上补齐到结构体对齐的整数倍

---

## 七、std::string 的对齐要求

`std::string` 是一个类对象，它的大小和对齐取决于编译器实现：

- 在 **64 位系统 (GCC/Clang, MSVC)**：
  - `sizeof(std::string)` 通常为 **32 字节**
  - `alignof(std::string)` 为 **8**
  - 因为内部包含指针（8 字节对齐）

- 在 **32 位系统**：
  - `sizeof(std::string)` 通常为 **16 字节**
  - `alignof(std::string)` 为 **4**
  - 因为指针大小为 4 字节

👉 可以通过以下代码在当前环境中验证：
```cpp
#include <iostream>
#include <string>

int main() {
    std::cout << "sizeof(std::string) = " << sizeof(std::string) << "\n";
    std::cout << "alignof(std::string) = " << alignof(std::string) << "\n";
}
```

---

## 八、自定义类型的对齐要求

对于用户自定义的结构体或类：

- 对齐数 = 其所有成员对齐数的最大值。
- 普通内建类型的对齐数在 64 位环境下 **不会超过 8**（double、long、指针都是 8）。
- 因此，如果不显式使用 `alignas` 或特殊 SIMD 类型（如 __m128 / __m256），自定义类型的对齐数通常 **≤ 8**。
- 结构体大小必须是该对齐数的整数倍。

### 示例

```cpp
struct Foo {
    char c;
    int i;
    double d;
};
// alignof(Foo) = 8, sizeof(Foo) = 16

struct Bar {
    Foo f;
    int x;
};
// alignof(Bar) = 8, sizeof(Bar) = 24
```

如果使用了 `alignas`：

```cpp
struct alignas(16) Vec4 {
    float x, y, z, w;
};
// alignof(Vec4) = 16, sizeof(Vec4) = 16
```

---

## 九、std::string 的对齐要求（补充）

- `std::string` 是一个类对象，它的对齐由内部最大成员决定（通常是指针）。
- 在 **64 位系统**：
  - `sizeof(std::string)` ≈ 32
  - `alignof(std::string)` = 8
- 在 **32 位系统**：
  - `sizeof(std::string)` ≈ 16
  - `alignof(std::string)` = 4

👉 因此在结构体中使用 `std::string` 成员时，通常会要求 **8 字节对齐**（64 位）。

---

## 十、内存对齐总结

1. **定义**
   - 内存对齐是指数据在内存中存放时，地址必须是其对齐数的整数倍。
   - 这样保证 CPU 可以高效地访问数据，避免跨越多个总线周期。

2. **规则**
   - 成员对齐 = min(自然对齐, 编译器最大对齐)。
   - 结构体对齐 = 其中最大成员对齐。
   - 结构体大小 = 向上补齐到结构体对齐的整数倍。

3. **常见对齐值（64 位环境，默认情况）**
   - char: 1
   - short: 2
   - int / float: 4
   - double / long / 指针: 8
   - 自定义类型: ≤ 8（除非显式使用 alignas 或 SIMD 类型）
   - std::string: 8

4. **例子**
   ```cpp
   struct A {
       char a;   // 偏移 0
       int b;    // 偏移 4
       short c;  // 偏移 8
   };
   // alignof(A) = 4, sizeof(A) = 12

   struct B {
       char a;   // 偏移 0
       double b; // 偏移 8
       int c;    // 偏移 16
   };
   // alignof(B) = 8, sizeof(B) = 24 (64 位)
   ```

---

# ✅ 最终总结
- **alignof(T)** 表示类型 T 在当前平台上的对齐要求。
- 普通内建类型在 64 位下最大对齐为 8。
- 自定义类型的对齐要求取决于内部最大成员，一般 ≤ 8。
- `std::string` 在 64 位下对齐数为 8，大小约为 32。
- 结构体大小必须补齐到整体对齐的整数倍，以保证数组中的每个元素都满足对齐要求。
