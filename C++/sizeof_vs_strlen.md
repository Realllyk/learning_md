# C/C++ 中 `sizeof` 与 `strlen` 速查

> **一句话对比**：`sizeof` 是编译期求**占用字节数**的**运算符**；`strlen` 是运行期求 **C 字符串长度（不含 `'\0'`）** 的**函数**。

---

## 1. 基本概念

### `sizeof`（运算符）
- 返回**字节数**（类型或表达式在内存中占用的大小），类型为 `size_t`。
- **多数情况下在编译期即可得出**（`constexpr`），与运行时数据无关。
- 作用对象：**类型**、**对象**、**表达式**。
- 对**数组**：得到**整个数组的字节数**，**不会**把数组衰减为指针（除非在函数形参位置）。
- 对**指针**：得到**指针本身**的大小（如 64 位系统通常是 8 字节），**与所指向区域大小无关**。

示例：
```cpp
char a[10] = "hello";
sizeof(a);           // 10（数组总容量，包含未使用位置）
sizeof("hello");     // 6  （字面量类型是 char[6]，含结尾 '\0'）
char* p = a;
sizeof(p);           // 8  （在 64 位上，指针大小）
```

### `strlen`（函数，声明于 `<cstring>`）
- 计算 **以 `'\0'` 结尾的 C 字符串** 的**字符个数**，**不**包含 `'\0'`。
- **运行期**逐字节查找，直到遇到 `'\0'` 停止。
- **要求**：传入的是**有效内存**，且**可读**，并且**一定有 `'\0'` 终止**；否则行为未定义（可能越界）。

示例：
```cpp
char s[] = "hello";
strlen(s);        // 5
char t[10] = {'h','e','l','l','o'}; // 没有显式 '\0' 终止
strlen(t);        // 未定义行为（可能越界读取）
```

---

## 2. 为何“结果不同”的常见场景

### 场景 A：在普通作用域（非形参）
```cpp
char arr[10] = "hello";
sizeof(arr);   // 10（数组容量）
strlen(arr);   // 5  （实际字符串长度）
```

### 场景 B：在**函数形参**位置发生“数组到指针衰减”
```cpp
void foo(char arr[]) {       // 等价于 void foo(char* arr)
    sizeof(arr);  // -> sizeof(char*)，64 位多为 8
    strlen(arr);  // 运行期根据内容计算
}
```
> 结论：**只有在定义处是数组类型时**，`sizeof` 才能得到数组总字节数；**一旦作为形参**，就只剩指针大小。

---

## 3. 易错点与知识点

- `sizeof("hello") == 6`，因为字符串字面量类型是 `const char[6]`（含终止符）。
- `strlen` 统计**字节数**，不是“字符数”。UTF‑8 下 `"中文"` 的 `strlen` 可能是 **6**（每个汉字 3 字节）。
- `sizeof(wchar_t)` 平台相关（Windows 上 2，Linux 上 4）；`strlen` 的宽字符版本是 `wcslen`。
- 对 `malloc` 得到的指针：`sizeof(ptr)` 仍是指针大小，**别用它当缓冲区长度**，长度需单独保存。
- `strlen` 访问未初始化或未以 `'\0'` 结尾的缓冲区 → **未定义行为**。

---

## 4. 在函数中安全获取“数组容量”的做法

### 4.1 模板 + 引用，保留数组类型信息（推荐）
```cpp
template <std::size_t N>
constexpr std::size_t array_size(const char (&)[N]) noexcept { return N; }

char buf[32];
static_assert(array_size(buf) == 32);
```

### 4.2 C 风格求元素个数（仅在同一作用域、非形参位置有效）
```cpp
#define COUNT_OF(a) (sizeof(a) / sizeof((a)[0]))
```

### 4.3 现代 C++ 替代方案
- 使用 `std::string`/`std::vector<char>`/`std::array<char, N>` 管理缓冲区；
- C++17：`std::size(arr)` 能在数组作用域得到元素个数；
- C++20：`std::span<char>` 传参，显式携带长度信息。

---

## 5. 对比速览表

| 维度 | `sizeof` | `strlen` |
| --- | --- | --- |
| 本质 | 运算符 | 函数（`<cstring>`） |
| 结果含义 | 占用**字节数** | C 字符串**长度**（不含 `'\0'`） |
| 发生时机 | 多为**编译期**（常量表达式） | **运行期**遍历 |
| 作用对象 | 类型/对象/表达式 | 以 `'\0'` 结尾的 `char*`/`char[]` |
| 对数组 | 得到**整个数组的字节数** | 读到 `'\0'` 为止 |
| 对形参 `T arr[]` | **衰减为指针** → 得到 `sizeof(T*)` | 正常工作 |
| 对指针 | 指针本身大小（与所指内容无关） | 可能越界（若无 `'\0'`） |
| 编译器能否检查 | 能（类型层面） | 难（运行期数据相关） |

---

## 6. 小结
- **记长用 `strlen`，记容量用 `sizeof`（但只在数组未衰减时）**。  
- 需要把“长度/容量”带进函数：**模板引用、`std::span`、或容器类**。  
- 操作 C 字符串务必保证 **`'\0'` 终止**，否则一切皆未定义。
