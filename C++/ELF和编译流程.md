# C++ 编译流程与 ELF 文件总结

## 1. ELF 文件是什么
ELF（Executable and Linkable Format）是 Linux/类 Unix 系统中广泛使用的一种二进制文件格式。  
它可以用来表示：
- **可执行文件**：最终可以运行的程序
- **目标文件 (.o)**：编译器生成的中间文件
- **共享库 (.so)**：运行时动态加载的库
- **核心转储文件 (core dump)**：程序崩溃时保存的内存映像

### ELF 文件结构
- **ELF Header**：整体信息（文件类型、入口地址等）
- **Program Header Table**：操作系统加载需要的段信息
- **Section Header Table**：代码段、数据段、符号表等信息
- **数据区**：代码和数据本体
  
  ![[Pasted image 20250903100455.png]]

---

## 2. C++ 编译流程

C++ 的编译过程一般分为四个阶段：

### 2.1 预处理 (Preprocessing)
- 输入：`.cpp` 源文件
- 输出：`.i` 文件
- 操作：
  - 展开 `#include`（拷贝整个头文件内容）
  - 替换 `#define` 宏
  - 处理条件编译（`#ifdef` 等）

### 2.2 编译 (Compilation)
- 输入：`.i`
- 输出：`.s`（汇编代码）
- 操作：把预处理后的源码翻译成汇编语言

### 2.3 汇编 (Assembling)
- 输入：`.s`
- 输出：`.o`（目标文件，ELF 格式）
- 操作：把汇编代码转换成机器码
- 特点：
  - 包含函数的实现（自己写的、inline、static）
  - 如果调用了外部函数（如 `printf`），会留下“空槽”（未定义符号）

### 2.4 链接 (Linking)
- 输入：多个 `.o` 文件 + 库文件
- 输出：最终可执行文件（ELF 格式）
- 操作：
  - 把多个目标文件合并
  - 用库文件或别的 `.o` 文件的定义填补“空槽”
  - 生成可执行文件

---

## 3. `.o` 文件和 `.so` 文件的区别
- `.o`：目标文件，由编译器生成的半成品，不能直接运行
- `.so`：共享库（Shared Object），打包好的函数集合，程序运行时动态加载
- 可执行文件：链接 `.o` 和 `.so` 后生成，可以直接运行

类比：
- `.o` = 零件（半成品）
- `.so` = 工具箱（可以被多个程序共享）
- 可执行文件 = 组装好的机器

---

## 4. inline 和 extern 的作用
- **inline 函数**：
  - 在调用点直接展开函数体，避免函数调用开销
  - 编译器可能忽略 inline 请求
  - 不会留下“空槽”

- **extern 关键字**：
  - 声明变量/函数在别处定义
  - 让编译器知道名字存在，但实现由链接器解决
  - 会留下“空槽”，由链接器填补

---

## 5. 总结流程图

```text
.cpp (源码)
   ↓ 预处理
.i (展开后的源码)
   ↓ 编译
.s (汇编代码)
   ↓ 汇编
.o (目标文件，ELF 格式，可能有空槽)
   ↓ 链接
[ 静态链接 ] + 其他 .o/.a = 可执行文件 (ELF)
[ 动态链接 ] + .so = 可执行文件 (ELF)
```

---

## 6. 核心结论
1. `.i` 文件由 `.cpp` 经过预处理生成，包含声明和/或定义，取决于源文件本身。
2. `.o` 文件是 ELF 格式的目标文件，可能有“空槽”。
3. `.so` 文件是 ELF 格式的共享库，供程序运行时使用。
4. 最终生成的可执行文件也是 ELF 文件。
