
---

## Redis 为什么快？
官方使用基准测试的结果是，**单线程的 Redis 吞吐量可以达到 10W/每秒**

Redis 采用单线程（网络 I/O 和执行命令）那么快，有以下几个原因：
- **Redis 的大部分操作都在内存中完成**，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或着网络带宽，而并非 CPU。既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案；
- **Redis 采用单线程模型可以避免了多线程之间的竞争**，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题；
- **Redis 采用了 I/O 多路复用机制** 处理大量的客户端 Socket 请求，I/O 多路复用机制是指 **一个线程处理多个 IO 流**，就是我们经常听到的 `select/epoll` 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket，内核会一直监听这些 Socket 上的连接请求或数据请求，一旦有请求到达，就会交给 Redis 线程处理，这就实现了 **一个 Redis 线程处理多个 IO 流** 的效果。


---

## Redis 哪些地方使用了多线程？

Redis **单线程** 指的是 **「接收客户端请求 -> 解析请求 -> 进行数据读写等操作 -> 发送数据给客户端」** 这个过程是由 **一个线程（主线程）** 来完成的，这也是我们常说 Redis 是单线程的原因。

但是，**Redis 程序并不是单线程的**，Redis 在启动的时候，会 **启动后台线程（BIO）**：
- **Redis 在 2.6 版本**，会启动 2 个后台线程，分别处理 **关闭文件**、**AOF 刷盘** 这两个任务；    
- **Redis 在 4.0 版本之后**，新增了一个新的后台线程，用来 **异步释放 Redis 内存**，也就是 **lazyfree 线程**。例如执行 `unlink key` / `flushdb async` / `flushall async` 等命令，会把这些删除操作交给后台线程来执行，好处是不会导致 Redis 主线程卡顿。因此，我们在删除大 key 时，应该使用 `unlink` 命令，而不是 `del` 命令，因为 `del` 是主线程处理的，可能导致 Redis 发生阻塞。


![[redis_multi_thread.webp]]


之所以 Redis 为 **「关闭文件、AOF 刷盘、释放内存」** 这些任务创建单独的线程来处理，是因为这些任务的操作都是 **耗时的**，如果把这些任务都放在主线程处理，那么 Redis 主线程就很容易发生阻塞，这样就无法处理后续的请求了。
后台线程相当于一个 **消费者**，生产者把耗时任务丢到任务队列中，**消费者（BIO）不停轮询这个队列，拿出任务去执行对应的方法即可**。

此外，从 **Redis 6.0 版本** 开始，Redis **支持 I/O 多线程**，允许多个 I/O 线程并行处理网络请求。这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在 **网络 I/O 处理**。
- Redis 6.0 通过 **多线程 I/O 处理网络请求**，提升了 I/O 的并行度。
- 但 Redis 仍然 **使用单线程执行命令**，即多线程 **仅处理 I/O 相关操作**，不会影响命令执行的单线程特性。
- 官方表示，**Redis 6.0 的多线程 I/O 至少提升了一倍的性能**。
- 默认情况下，多线程 I/O 只针对 **发送响应数据（write client socket）**，如果需要 **开启多线程处理客户端请求（read client socket）**，则需要在 `redis.conf` 配置文件中设置 `io-threads-do-reads yes`。

因此，Redis 主要仍然是单线程处理命令，但在 **后台任务（如 AOF、lazyfree）和 I/O 处理** 方面采用了多线程优化。


---


## AOF刷盘

AOF（Append-Only File）是 Redis 提供的一种 **持久化机制**，它的作用是 **记录所有写操作（增、删、改），以便在 Redis 重启时能恢复数据**。而 **AOF刷盘**（AOF flushing）则指的是 **将 AOF 缓冲区中的数据同步写入磁盘**，确保数据的持久化。

### **AOF 的工作原理**
1. **Redis 执行写命令**（如 `SET key value`）。
2. **该命令会被追加（append）到 AOF 缓冲区**，但此时数据仍在内存中，并未写入磁盘。
3. **根据刷盘策略（sync 策略），决定何时将 AOF 缓冲区的数据真正写入磁盘**：
    - **`always`（每次写入命令后立刻同步刷盘）**：最安全，但性能较低。
    - **`everysec`（每秒刷盘一次，默认）**：性能和安全性的折中方案，每秒执行一次 `fsync()`，可能会丢失 1 秒数据。
    - **`no`（由操作系统决定刷盘时机）**：最快，但可能会丢失较多数据。

### **AOF 刷盘的作用**
1. **防止数据丢失**：即使 Redis 进程崩溃，AOF 也能通过记录的命令日志 **完全恢复数据**。
2. **提供更强的数据持久性**：相比 RDB（Redis 数据库快照），AOF 记录 **每个写操作**，恢复时丢失数据的概率更小。
3. **支持后台刷盘**：Redis 采用 **后台线程（BIO）** 来异步执行 AOF 刷盘，避免主线程阻塞，影响性能。

### **AOF 相关的 BIO 线程**
在 Redis 2.6 之后，AOF 刷盘会使用 **后台线程（BIO，Background I/O）** 进行异步写入：
- Redis 主线程 **只负责写入 AOF 缓冲区**，不会直接进行刷盘。
- **后台 BIO 线程负责定期刷盘**，确保不会影响 Redis 的主线程性能。



---


## 为什么 Redis 需要使用 I/O 多路复用？

因为 Redis 是跑在 **单线程** 中的，所有的操作都是按 **顺序执行** 的，但是由于 **读写操作等需要用户输入或输出** 都是 **阻塞** 的，所以 I/O 操作往往不能直接返回，这会导致某一个文件的 I/O 阻塞，从而让整个进程无法对其它客户端提供服务。

为了解决这个问题，Redis 采用 **I/O 多路复用机制**，让 **单线程（进程）** 的服务端应用同时处理 **多个客户端的事件**。

**I/O 多路复用** 的核心：
- **“多路”** 指的是 **多个网络连接客户端**；
- **“复用”** 指的是 **复用同一个线程（单进程）** 进行处理。

I/O 多路复用机制的实现方式是 **使用一个线程来检查多个 Socket 的就绪状态**，在单个线程中通过 **追踪每一个 socket（I/O 流）** 的状态，来 **管理并处理多个 I/O 流**。

![[redis_multi_IO.webp]]
### I/O 多路复用的工作方式
1. **每个 socket 客户端与服务器端连接**，会生成一个 **套接字描述符（FD）**，每个 socket 连接对应一个 FD。
2. **多个客户端与服务器连接时**，Redis 使用 **I/O 多路复用程序**，将客户端 **socket 对应的 FD 注册到监听列表（一个队列）** 中。
3. **当客户端执行** `**read**`**、**`**write**` **操作时**，I/O 多路复用程序会将命令封装成 **一个事件**，并绑定到对应的 FD 上。
4. **Redis 事件处理器会监听多个 FD 的读写情况**，当 `accept`、`read`、`write` 和 `close` 事件发生时，文件事件处理器会回调 FD 绑定的事件处理器执行相应的操作。

例如：
- 在 Redis 的 I/O 多路复用程序中，使用 `epoll` 作为示例，多个客户端连接 Redis 服务器时，Redis **会将客户端 socket 对应的 FD 注册进 epoll**。
- `epoll` 同时监听多个 **文件描述符（FD）** 是否有数据到达，如果有数据到来，就通知 **事件处理器** 进行处理，**不会因为某个客户端未发送数据而等待**。
    

整个文件事件处理器是在 **单线程** 上运行的，但通过 **I/O 多路复用机制**，实现了同时对多个 FD 读写的监听，避免 I/O 阻塞的问题，从而提高了 Redis 的网络通信性能。
Redis 的 I/O 多路用模式是 **Reactor 设计模式** 实现的。