---

---

---

## 过期删除策略和内存淘汰策略的区别

### 区别：
- **内存淘汰策略**：当 **Redis 内存满** 时，Redis 触发 **内存淘汰策略**，删除一些 **不必要的数据**，以腾出空间存储新的数据。
- **过期键删除策略**：针对 **已设置过期时间的键**，当过期后，Redis 需要 **删除这些键值**。Redis 采用 **惰性删除 + 定期删除** 两种策略进行处理。


---

## 介绍一下Redis 内存淘汰策略

在 32 位操作系统中，maxmemory 的默认值是 3G，因为 32 位的机器最大只支持 4GB 的内存，而系统本身就需要一定的内存资源来支持运行，所以 32 位操作系统限制最大 3 GB 的可用内存是非常合理的，这样可以避免因为内存不足而导致 Redis 实例崩溃。

Redis 内存淘汰策略共有八种，这八种策略大体分为「不进行数据淘汰」和「进行数据淘汰」两类策略。

![[redis_volatile_category.webp]]


### 1. 不进行数据淘汰的策略：

- **noeviction**（Redis3.0 之后，默认的内存淘汰策略）：它表示当运行内存超过最大设置内存时，不淘汰任何数据，这时如果有新的数据写入，会报错通知并禁止写入，不淘汰任何数据，但是如果没有数据写入的话，只是单纯的查询或者删除操作的话，还是可以正常工作。

### 2. 进行数据淘汰的策略：

针对「进行数据淘汰」这一类策略，又可以细分为「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」这两种策略。

#### 在设置了过期时间的数据中进行淘汰：

- **volatile-random**：随机淘汰设置了过期时间的任意键值；
- **volatile-ttl**：优先淘汰更早过期的键值；
- **volatile-lru**（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；
- **volatile-lfu**（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；
#### 在所有数据范围内进行淘汰：

- **allkeys-random**：随机淘汰任意键值；
- **allkeys-lru**：淘汰整个键值中最久未使用的键值；
- **allkeys-lfu**（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。


---


## 介绍一下Redis 过期删除策略

Redis 选择「惰性删除+定期删除」这两种策略配和使用，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡。

### 惰性删除

Redis 的**惰性删除策略**由 `db.c` 文件中的 `expireIfNeeded` 函数实现，代码如下：

Redis 在访问或者修改 key 之前，都会调用 `expireIfNeeded` 函数对其进行检查，检查 key 是否过期：

- 如果过期，则删除该 key，至于选择异步删除，还是选择同步删除，根据 `lazyfree_lazy_expire` 参数配置决定（Redis 4.0 版本开始提供参数），然后返回 null 客户端；
- 如果没有过期，不做任何处理，然后返回正常的键值对给客户端；

**惰性删除的流程图如下：**

![[lazy_delete.webp]]

### 定期删除

Redis 的**定期删除**是每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期 key。

![[time_delte.webp]]


#### 1. 这个间隔检查的时间是多长呢？

在 Redis 中，默认是每秒进行 10 次过期检查一次数据库，此配置可通过 Redis 的配置文件 `redis.conf` 进行配置，配置键为 `hz` 它的默认值是 10。特别强调下，每次检查数据库并不是遍历过期字典中的所有 key，而是从数据库中随机取一定数量的 key 进行过期检查。

#### 2. 随机抽查的数量是多少呢？

我查了下源码，定期删除的实现位于 `expire.c` 文件下的 `activeExpireCycle` 函数中，其中随机抽查的数量由 `ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP` 定义，它是写死在代码中的，数值是 20。也就是说，数据库每轮抽查时，会随机选择 20 个 key 判断是否过期。接下来，详细说说 Redis 的定期删除的流程：

1. 从过期字典中随机抽取 20 个 key；
2. 检查这 20 个 key 是否过期，并删除已过期的 key；
3. 如果本轮检查的已过期 key 的数量，占比大于 5%（20/4），也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮检查。

可以看到，定期删除是一个循环的流程。Redis 为了保证定期删除不会出现循环过度，导致线程卡死现象，为此增加了定期删除循环的时间上限，默认不会超过 25ms。


---

## 为什么不过期立即删除
在过期 key 比较多的情况下，删除过期 key 可能会占用相当一部分 CPU 时间，在内存不紧张但 CPU 时间紧张的情况下，将 CPU 时间用于删除当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。所以，定时删除策略对 CPU 不友好。