# Redis 事务 vs MySQL 事务 学习笔记（扩展版）

## 一、Redis 与 MySQL 事务对比

| 维度 | Redis 事务（MULTI/EXEC/WATCH/Lua） | MySQL 事务（InnoDB 为例） |
|---|---|---|
| 目标 | 将一组命令顺序、原子地提交执行，减少并发干扰 | 满足 ACID，保障强一致的持久化数据更新 |
| ACID 支持 | **A**：EXEC 阶段单线程顺序执行，不被打断；但不支持部分回滚。**C**：靠应用保证。**I**：无隔离级别，依赖 WATCH。**D**：由 RDB/AOF 决定，可能丢失数据 | **A**：要么全成，要么全撤。**C**：约束/外键等保障。**I**：多级隔离（RU/RC/RR/SER）。**D**：redo log + binlog，保证提交不丢 |
| 回滚能力 | 不支持部分回滚，运行时错误不会撤销之前操作 | 完整回滚，任意失败可恢复 |
| 并发控制 | 单线程 + WATCH 实现乐观锁；无隔离级别 | 行锁/间隙锁/MVCC，支持死锁检测 |
| 隔离性 | 无官方隔离级别，依赖 WATCH | 明确隔离级别，读写一致性可控 |
| 跨键/分片 | Redis Cluster 需同 slot，跨 slot 不支持 | 跨行跨表天然支持；分布式需中间件 |
| 持久化 | AOF/RDB，可能丢最近数据 | redo/binlog 两阶段提交，保证已提交数据不丢 |
| 性能取向 | 内存型，极快，适合高并发轻量事务 | 磁盘型，强一致，适合账务型事务 |

---

## 二、Redis 中 WATCH 的作用

`WATCH` 是 Redis 提供的乐观锁机制，用于配合事务检测并发冲突。

### 工作流程
1. **WATCH key1 key2 ...**  
   开始监视一个或多个键。
2. **MULTI**  
   开启事务，将命令放入队列。
3. **EXEC**  
   - 如果监视的键在 EXEC 前未被修改，事务内命令依次执行。  
   - 如果监视的键被修改过，事务失败，返回 nil。  
4. **UNWATCH**  
   可取消监视。

### 示例

```bash
# 客户端A
WATCH balance
val = GET balance   # 假设结果是 100
MULTI
DECRBY balance 50
EXEC
```

如果在 `EXEC` 前 `balance` 被别的客户端修改，事务将失败。

### 特点
- 乐观锁风格：检查冲突而非直接上锁。  
- 适合秒杀、扣库存、转账等场景。  
- 不保证回滚，需要业务方设计补偿机制。

---

## 三、Redis 事务的错误处理

Redis 事务在不同阶段对错误的处理方式不同：

- **命令入队阶段（MULTI → EXEC 之间）**：  
  - 如果语法错误，Redis 会标记事务为 dirty，最终 `EXEC` 直接失败，队列中命令不会执行。  
  - 因为尚未执行命令，所以不存在“回滚”。

- **事务执行阶段（EXEC 之后）**：  
  - Redis 会顺序执行事务中的命令。  
  - 如果某条命令运行时报错（如类型错误），该命令失败，但之前执行的命令不会回滚，后续命令也会继续执行。  
  - 因此 Redis 不支持运行时回滚，应用层需要补偿逻辑。

**总结**：  
- 入队语法错 → 整个事务不执行。  
- 执行期运行错 → 部分失败，其他命令继续，不回滚。

---

## 四、Redis 事务的底层实现

Redis 的事务底层实现依赖于 **单线程模型、命令队列和乐观锁机制**。

### 1. 单线程模型
- Redis 是单线程处理命令，保证 `EXEC` 阶段的事务命令不会被并发打断。  
- 这确保了事务的原子性：事务命令作为一个批次顺序执行。

### 2. 事务的生命周期
- **MULTI**：客户端进入事务状态，后续命令仅入队，不执行。  
- **命令入队**：检查语法，合法的命令加入队列，错误则标记事务为 dirty。  
- **EXEC**：如果事务 dirty → 返回 nil，不执行；否则顺序执行命令。  
- **DISCARD**：清空命令队列，退出事务状态。  
- **WATCH/UNWATCH**：监控或取消监控指定键，用于乐观锁。

### 3. 错误机制
- **语法错误**：提前拦截，事务整体取消。  
- **运行时错误**：只影响当前命令，不回滚已执行的部分。

### 4. 与 MySQL 的差异
- MySQL 用 undo/redo log、锁、MVCC 实现真正的 ACID。  
- Redis 事务更轻量，没有回滚机制，实质上是“命令队列 + 单线程顺序执行 + 可选乐观锁”。

### 5. 类比
- `MULTI`：开始点菜单。  
- 命令入队：写在小票上，不立刻做菜。  
- `EXEC`：一次性按小票顺序做完。  
- 点菜时写错 → 整单作废；做菜时缺原料 → 只这道菜失败，其余照常。

---

## 五、总结

- **Redis 事务**：简单快速，保证命令顺序执行，不支持运行时回滚。  
- **MySQL 事务**：完整 ACID，适合强一致性要求的业务。  
- **WATCH**：提供乐观锁，避免并发冲突。  
- **错误处理**：入队错则整体放弃，执行错只影响单条命令。  
- **底层实现**：依赖单线程顺序执行和命令队列，而非日志和锁。  
