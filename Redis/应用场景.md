
## Redis 应用场景是什么？
Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此 **读写速度非常快**，常用于 **缓存、消息队列、分布式锁** 等场景。
- **缓存**：Redis 最常见的用途是作为缓存系统。通过将热点数据存储在内存中，可以极大地提高访问速度，减少数据库负载。这对需要快速响应时间的应用程序非常重要。
- **排行榜**：Redis 的有序集合特性非常适用于实现排行榜和排名系统，可以方便地进行数据排序和排名。
- **分布式锁**：Redis 的特性可以用来实现分布式锁，确保多个进程或服务之间的数据操作的原子性和一致性。
- **计数器**：由于 Redis 的原子操作和高性能，它非常适合用于实现计数器和统计数据的存储，如网站访问量统计、点赞数据统计等。
- **消息队列**：Redis 的发布订阅功能使其成为一个轻量级的消息队列，它可以用来实现发布和订阅模式，以便实时处理消息。


---
## Redis 除了缓存，还有哪些应用？

### Redis 实现消息队列
- **使用 Pub/Sub 模式**：Redis 的 Pub/Sub 是一种基于发布/订阅的消息模式，任何客户端都可以订阅一个或多个频道，发布者可以向特定频道发送消息，所有订阅该频道的客户端都会收到此消息。该方式实现起来比较简单，发布者和订阅者全解耦，支持模式匹配订阅。但这种方式不支持消息持久化，消息发布后若订阅者不在线则会被丢弃，**不保证消息的顺序和可靠性**。
- **使用队列结构**：使用 `BLIST` 的方式通常是使用 `LPUSH` 命令将消息推入一个列表，消费者使用 `BLPOP` 或 `BRPOP` 阻塞地从列表中取出消息（先进先出 FIFO）。这种方式可以实现简单的任务队列，并结合 Redis 的过期时间特性实现消息的 TTL。但需要客户端自己实现消息确认、重试等机制，相比专业的消息队列功能较弱。
### Redis 实现分布式锁
- **set nx 方式**：Redis 提供了几种方式来实现分布式锁，最常用的是基于 `SET` 命令的竞争锁机制。客户端可以使用 `SET resource_name lock_value NX PX milliseconds` 命令设置锁，其中 `NX` 表示只有当键不存在时才设置，`PX` 指定锁的有效时间（毫秒）。如果设置成功，则认为客户端获得锁。客户端完成操作后，解锁时需要先判断锁是否是自己持有的，再进行删除。为保证原子性，可以用 Lua 脚本来实现。
- **RedLock 算法**：为提高分布式锁的可靠性，Redis 作者提出了 **RedLock 算法**，它基于多个独立的 Redis 实例来实现一个更安全的分布式锁。客户端需要尝试在 **多个（大于半数）Redis 实例** 上加锁，只有当大多数实例上加锁成功时才认为获取锁成功。锁的超时时间应该大于单个实例的超时时间，以避免死锁。该方式可以**跨多个节点减少单点故障的影响**，提高了锁的可靠性和安全性。


----

## 缓存雪崩解决方案

![[缓存雪崩.webp]]
### 1. 均匀设置过期时间
如果要给缓存数据设置过期时间，应该避免将大量的数据设置成同一个过期时间。我们可以在对缓存数据设置过期时间时，**给这些数据的过期时间加上一个随机数**，这样就保证数据不会在同一时间过期。

### 2. 互斥锁
当业务线程在处理用户请求时，**如果发现访问的数据不在 Redis 里，就加个互斥锁**，保证同一时间内只有一个请求来构建缓存（从数据库读取数据，再将数据更新到 Redis 里）。当缓存构建完成后，再释放锁。
- 不能采取无互斥锁的请求，否则会导致大量请求同时读数据库。
- 要么返回已有缓存值，要么返回默认值。
- 在实现互斥锁时，**最好设置超时时间**，否则第一个请求拿到了锁，但由于某种意外情况一直阻塞，导致锁一直不释放，其他请求就会一直被锁住，影响系统正常运行。

### 3. 后台线程更新
业务线程不再负责更新缓存，而是**让缓存“永久有效”**，并**将更新缓存的工作交由后台线程定时更新**。


---


## 缓存击穿解决方案
### 1. 互斥锁方案
保证同一时间只有一个业务线程更新缓存，**未能获取互斥锁的请求**，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。

### 2. 不给热点数据设置过期时间
由后台异步更新缓存，或者在**热点数据准备要过期前**，提前通知后台线程更新缓存以及重新设置过期时间。


---


## 缓存穿透解决方案

### 1. 非法请求的限制

当有大量恶意请求访问不存在的数据时，也会发生缓存穿透。因此在 API 入口处，我们要**判断请求参数是否合法**，请求参数是否包含非法值、请求字段是否存在。如果判断出是恶意请求，则直接返回错误，避免进一步访问缓存和数据库。

### 2. 缓存空值或默认值

当我们线上业务发现缓存穿透的现象时，可以针对查询的数据，在缓存中**设置一个空值或默认值**，这样后续请求就可以从缓存中读取空值或默认值，返回给应用，而不会继续查询数据库。

### 3. 布隆过滤器

我们可以在写入数据库数据时，**使用布隆过滤器做标记**，然后在用户请求到来时，业务线程确认缓存失效后，可以**通过查询布隆过滤器快速判断数据是否存在**。如果数据不存在，就不用查询数据库来判定是否存在。

- 即使发生了缓存穿透，大量请求会先查询 Redis 和布隆过滤器，而不会查询数据库，**确保数据库正常运作**。
    
- Redis 本身也支持布隆过滤器，可高效应对此类问题。


---


## 布隆过滤器原理介绍

布隆过滤器由 **「初始值都为 0 的位图数组」** 和 **「N 个哈希函数」** 两部分组成。当我们在写入数据库数据时，在布隆过滤器里做个标记，这样下次查询数据是否在数据库时，只需要查询布隆过滤器，如果查到数据没有被标记，说明不存在于数据库中。

![[布隆过滤器.webp]]

布隆过滤器会通过 **3 个操作** 完成标记：
1. **第一步**，使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；
2. **第二步**，将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置；
3. **第三步**，将每个哈希值在位图数组的对应位置的值设置为 1。

### 示例：
假设一个位图数组长度为 8，布隆过滤器有 3 个哈希函数。
- 当数据 x 进入数据库后，会计算出 3 个哈希值，并在位图数组的 1、4、6 位置设置为 1。
- 查询数据 x 是否存在时，只需要检查 1、4、6 位置是否全为 1。
- 只要有一个为 0，就说明数据不在数据库中。
### 布隆过滤器的特点：
- 由于基于哈希函数查找，**存在哈希冲突的可能性**，例如数据 x 和 y 可能被映射到相同位置，导致误判数据存在。
- **查询到数据存在，不代表数据一定存在**，但查询到数据不存在，则数据库一定不含该数据。