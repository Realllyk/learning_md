
## Redis中哈希表是怎么扩容的

在 Redis 中，`rehash`（重新哈希）是针对 `hash` 数据结构（字典）的一种动态调整机制，主要用于 **扩展或缩小** `hash` 结构，以优化存储和访问性能。Redis 的 `hash` 结构底层是 **哈希表（dict）**，支持自动扩展和收缩。

### 1. `rehash` 的触发条件

Redis 的哈希表（dict）默认使用 **两个哈希表**（ht[0] 和 ht[1]），但通常只有 ht[0] 处于活跃状态。当满足以下条件之一时，会触发 `rehash` 操作：

![[redis_hash.webp]]


1. **负载因子超出阈值**：
    - 当哈希表的大小（bucket 数量）不足以存储当前元素，并且**负载因子超过一定阈值**，会触发扩展 rehash。
    - 计算公式：
      ![[rehash_taggle.png]]
    - 阈值：
        - 当 Redis **没有进行 bgsave 或 bgrewriteaof** 时，负载因子 > **1**，触发扩展。
        - 当 Redis **正在执行 bgsave 或 bgrewriteaof** 时，负载因子 > **5**，触发扩展。
2. **键值对减少，导致表过于稀疏**：
    - 当删除了大量键值对，使得哈希表的负载因子太小，Redis 可能会缩小哈希表，以减少内存占用。

### 2. Rehash的过程
随着数据逐步增多，触发了 rehash 操作，这个过程分为三步：
- 给「哈希表 2」分配空间，一般会比「哈希表 1」大 2 倍；
- 将「哈希表 1」的数据迁移到「哈希表 2」中；
- 迁移完成后，「哈希表 1」的空间会被释放，并把「哈希表 2」设置为「哈希表 1」，然后在「哈希表 2」新创建一个空白的哈希表，为下次 rehash 做准备。

![[rehash_process.webp]]

#### 渐进式 rehash
这个过程看起来简单，但是其实第二步很有问题，如果「哈希表 1」的数据量非常大，那么在迁移至「哈希表 2」的时候，因为涉及大量的数据拷贝，此时可能会对 Redis 造成阻塞，无法服务其他请求。
为了避免 rehash 在数据迁移过程中，因为拷贝数据的耗时，影响 Redis 性能的问题，所以 Redis 采用了 **渐进式 rehash**，也就是将数据的迁移工作不再是一次性迁移完成，而是 **分多次迁移**。

#### 渐进式 rehash 步骤如下：
1. 给「哈希表 2」分配空间；
2. 在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会 **顺序将「哈希表 1」中索引位置上的所有 key-value 迁移到「哈希表 2」上**；
3. 随着处理客户端发起的哈希表操作请求数量越来越多，最终在某个时间点会把「哈希表 1」的所有 key-value 迁移到「哈希表 2」，从而完成 rehash 操作。

这种操作 **将原本一次性大量数据迁移工作的开销，分摊到多个处理请求的过程中，避免了一次性 rehash 的耗时操作**。

#### rehash 期间的数据查询
在进行渐进式 rehash 的过程中，会有两个哈希表，所以在 rehash 进行期间，哈希表元素的删除、查找、更新等操作 **都会在这两个哈希表上进行**。例如：
- **查找 key** 时，先会在「哈希表 1」里面查找，如果没找到，就会继续到「哈希表 2」里面查找。

另外，在渐进式 rehash 进行期间，新增的 key-value 对，会 **被保存到「哈希表 2」里面**，而「哈希表 1」则不会再进行任何添加操作。这保证了「哈希表 1」的 key-value 数量只会减少，随着 rehash 操作的完成，最终「哈希表 1」就会变为空。


---

## String 是使用什么存储的? 为什么不用 C 语言中的字符串?

Redis 的 String 字符串是用 SDS 数据结构存储的。
下图就是 Redis 5.0 的 SDS 的数据结构：

![[redis_SDS.webp]]

### 结构中的每个成员变量介绍：
- **len**：记录了字符串长度，这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O(1)。
- **alloc**：分配给字符串数组的空间长度。这样在修改字符串的时候，可以通过 `alloc - len` 计算出剩余的空间大小，可以来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才会执行实际的修改操作。所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现如 C 语言字符串的缓冲区溢出的问题。
- **flags**：用来表示不同类型的 SDS。一共设计了 5 种类型，分别是 `sdshdr5`、`sdshdr8`、`sdshdr16`、`sdshdr32` 和 `sdshdr64`，后面会说明区别。
- **buf[]**：字符数组，用来保存实际数据。不仅可以保存字符，也可以保存二进制数据。

总体来说，Redis 的 SDS 结构在原本字符数组之上，增加了三个元数据：`len`、`alloc`、`flags`，用来解决 C 语言字符串的缺陷。

### O(1) 复杂度获取字符串长度
C 语言的字符串长度获取使用 `strlen` 函数，需要通过遍历的方式来统计字符串长度，时间复杂度是 O(N)。
而 Redis 的 SDS 结构因为加入了 `len` 成员变量，那么获取字符串长度的时候，直接返回这个成员变量的值就行，所以复杂度只有 O(1)。

### 二进制安全
因为 SDS 不需要用 "\0" 字符来标识字符串结束了，而是有个专门的 `len` 成员变量来记录长度，所以可以存储包含 "\0" 的数据。但是 SDS 为了兼容部分 C 语言标准库的函数，SDS 字符串结尾还是会加上 "\0" 字符。
因此，SDS 的 API 都是以处理二进制的方式来处理 SDS 存放在 `buf[]` 里的数据，程序不会去对其中的数据做任何限制，数据写入的时候是什么样的，它被读取时就是什么样的。
通过使用二进制安全的 SDS，而不是 C 字符串，使得 Redis 不仅可以保存文本数据，也可以保存任意格式的二进制数据。

### 不会发生缓冲区溢出
C 语言的字符串标准库提供的字符串操作函数，大多数（比如 `strcat` 追加字符串函数）都是不安全的，因为这些函数把缓冲区大小是否满足操作需求的工作交由开发者来保证，程序内部并不会判断缓冲区大小是否足够，当发生了缓冲区溢出就有可能造成程序异常结束。
所以，Redis 的 SDS 结构里引入了 `alloc` 和 `len` 成员变量，这样 SDS API 通过 `alloc - len` 计算，可以算出剩余可用的空间大小，这样在对字符串做修改操作的时候，就可以由程序内部判断缓冲区大小是否足够。
而且，**当判断出缓冲区大小不够用时，Redis 会自动将大 SDS 的空间扩大，以满足修改所需的大小**。

--