# 用户态与内核态切换 vs 进程切换

## 1. 用户态与内核态切换

### 概念
- **用户态（User Mode）**：CPU 运行在低特权级（Ring 3），只能访问用户空间，不能执行特权指令。
- **内核态（Kernel Mode）**：CPU 运行在高特权级（Ring 0），可以访问整个虚拟内存，执行所有指令。

### 触发条件
1. **系统调用（System Call）**：程序主动请求内核服务（如 `read`、`write`）。
2. **中断（Interrupt）**：外设事件（如时钟中断、I/O 完成）。
3. **异常（Exception）**：如缺页异常、除零错误。

### 切换过程
- CPU 发现特权事件，保存当前用户态寄存器、PC 到内核栈。
- 切换到内核栈，修改特权级别，进入内核态入口。
- 执行内核服务代码。
- 完成后通过 `iret/sysret` 恢复寄存器和用户态 PC，回到用户态。

### 特点
- **同一个进程** 内部的特权级别切换。
- 页表不变，仅切换 **栈指针（用户栈 → 内核栈）** 和 **特权级**。
- 开销相对较小。

---

## 2. 进程切换

### 概念
- 操作系统调度器将 CPU 控制权从一个进程切换到另一个进程。

### 触发条件
1. 时间片用完。
2. 更高优先级进程就绪。
3. 当前进程阻塞（等待 I/O、资源等）。

### 切换过程
- 保存当前进程的 **上下文**（寄存器、程序计数器、内核栈指针等）。
- 切换 **页表基址（CR3）**，更新虚拟内存空间。
- 切换到新进程的内核栈和上下文。
- 恢复新进程的寄存器，继续执行。

### 特点
- **不同进程之间** 的切换。
- 涉及页表切换（用户空间变化，内核空间共享）。
- 开销大于用户态/内核态切换。

---

## 3. 两者比较

| 对比维度 | 用户态 ↔ 内核态切换 | 进程切换 |
|----------|--------------------|-----------|
| 本质 | 特权级别切换（同一进程） | CPU 执行流在不同进程间切换 |
| 栈使用 | 用户栈 ↔ 内核栈 | 切换到另一个进程的内核栈 |
| 页表 | 不切换，仍是同一份页表 | 切换页表基址（CR3） |
| 是否换进程 | 否 | 是 |
| 开销大小 | 较小 | 较大 |
| 触发条件 | 系统调用、中断、异常 | 调度、时间片用完、阻塞/唤醒 |

---

## 4. 总结
- **用户态 ↔ 内核态切换**：同一进程的权限级别切换，依赖栈指针和 CPU 特权级的改变。
- **进程切换**：CPU 从一个进程转到另一个进程，需要保存/恢复上下文并切换页表，开销更大。
