
## 操作系统的内存管理
操作系统设计了虚拟内存，每个进程都有自己的独立的虚拟内存，我们所写的程序不会直接与物理内存打交道。

有了虚拟内存之后，它带来了这些好处：
1. **虚拟内存可以使得进程对运行内存超出物理内存大小**，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。
2. **由于每个进程都有自己的页表，所以每个进程的虚拟内存空间都是相互独立的**。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。
3. **页表里的页表项中除了存了物理地址之外，还有一些标志位的特性**，比如控制一页的读写权限，标记该页是否在内存等。在内存访问方面，操作系统提供了更好的安全性。

Linux 是通过对内存分页的方式来管理内存，**分页是把整个虚拟和物理内存空间切割成一段段固定大小的块**，这样的块连续并且大小是固定的内存空间，我们叫**页（Page）**。在 Linux 下，每一页的大小为 4KB。
虚拟地址与物理地址之间通过**页表**来映射，如下图：

![[memory_management.webp]]

页表是存储在内存里的，**内存管理单元（MMU）** 就做将虚拟内存地址转换成物理地址的工作。
而当进程访问的虚拟地址在页表中查不到时，系统会产生一个**缺页异常**，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。


---


## 页表

**分页是把整个虚拟和物理内存空间切割成一段段固定大小的块**，这样一个连续并且尺寸固定的内存空间，我们叫**页（Page）**。在 Linux 下，每一页的大小为 4KB。

虚拟地址与物理地址之间通过**页表**来映射。

![[memory_management.webp]]

<span style="color: blue;">页表是存储在内存里的</span>，**内存管理单元（MMU）** 就负责将虚拟内存地址转换成物理地址的工作。

而当进程访问的虚拟地址在页表中查不到时，系统会产生一个**缺页异常**，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。

内存分页由于内存空间被预先划分好的块，也不会像内存分段一样，在段与段之间产生较大的间隙。**由于用了分页，页与页之间是紧密排列的，所以不会有外部碎片。**

但是，分页的最小分配单位是页，即便程序不足一页大小，我们最小只能分配一页，所以会出现**内部碎片**。

在分页机制下，虚拟地址分为两部分，**页号**和**页内偏移**。
- **页号**：作为页表的索引。
- **页表**：存储物理页的基地址。
- **页内偏移**：用于计算具体的物理地址。

![[virtual_address_to_mac_address.webp]]
### 内存地址转换的步骤：
1. 把虚拟内存地址，切分成页号和偏移量；
2. 根据页号，从页表里查询对应的物理页号；
3. 直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。


---


## 段式内存管理

虚拟地址也可以通过**段表**与物理地址进行映射的，分段机制会把程序的虚拟地址分成多个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址。

![[segment.png]]

如果要访问段 3 中偏移量 500 的虚拟地址，我们可以计算出物理地址为：
**段 3 基地址 7000 + 偏移量 500 = 7500**。


---


## 用户态内存布局

![[user_state_memory.webp]]

用户空间内存，从**低到高**分别是 6 种不同的内存段：
- **代码段**，包括二进制可执行代码；
- **数据段**，包括已初始化的静态变量和全局变量；
- **BSS 段**，包括未初始化的静态变量和全局变量；
- **堆**，包括动态分配的内存，从低地址开始向上增长；
- **文件映射段**，包括动态、共享内存等；
- **栈**，包括局部变量和函数调用的上下文等。栈的大小一般是 **8MB**，当然系统也提供了参数，以便我们自定义大小。

上图中的内存布局可以看到，代码段下面还有一段不可用的内存空间（灰色部分），这块区域称为**保留区**，主要是为了防止无效指针访问。通常 C 语言中无效的 `NULL` 指针就是指向这块区域，避免程序因 bug 访问无效地址导致崩溃。

在这 7 个内存段中，**堆和文件映射段**的内存是动态分配的。例如，使用 C 语言标准库的 `malloc()` 或 `mmap()`，就可以分别在堆和文件映射区动态分配内存。