## 为什么并发执行线程要加锁？
并发执行线程需要加锁主要是为了保护共享数据，防止出现"竞态条件"。

"竞态条件"是指当多个线程同时访问和操作同一块数据时，最终结果依赖于线程的执行顺序，这可能导致数据的不一致性。

通过加锁，我们可以确保在任何时刻只有一个线程能够访问共享数据，从而避免"竞态条件"，确保数据的一致性和完整性。


---


## 
## 自旋锁是什么？应用在哪些场景？

自旋锁加锁失败后，线程会<span style="color: blue;">忙等待</span>，直到它拿到锁。

自旋锁是通过 CPU 提供的 CAS 函数（Compare And Swap），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。

一般加锁的过程，包含两个步骤：
- 第一步，查看锁的状态，如果锁是空闲的，则执行第二步；    
- 第二步，将锁设置为当前线程持有；

CAS 函数把这两个步骤合并成一条硬件级指令，形成<span style="color: blue;">原子指令</span>，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。

比如，假设锁对象 lock，整数 0 表示空闲状态，整数 pid 表示线程 ID，那么 CAS(lock, 0, pid) 就表示自旋锁的加锁操作，CAS(lock, pid, 0) 则表示解锁操作。

使用自旋锁的时候，当发生多线程竞争争夺锁的情况时，加锁失败的线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用 while 循环等待实现，不过最好是使用 CPU 提供的 PAUSE 指令来实现「忙等待」，因为可以减少循环等待时的耗电量。

自旋锁是最简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。<span style="color: blue;">CAS(lock, pid, 0)需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断调度其他线程），否则，自旋锁在单核 CPU 上无法使用，因为一个旋转的线程永远不会放弃 CPU</span>。

自旋锁开销少，在多核系统下一般不会主动产生线程切换，适合异步-协程等在用户态切换请求的编程方式，但如果被锁住的代码执行时间过长，自旋的线程会占用 CPU 资源，所以自旋的时间和被锁住的代码执行的时间是「正比」的关系，我们需要注意这一点。

自旋锁与互斥锁使用层面上有不同：<span style="color: blue;">当加锁失败时，互斥锁用「线程切换」来应对，自旋锁用「忙等待」来应对</span>。

<span style="color: blue;">如果你能确定被锁住的代码执行时间很短，那么应该使用自旋锁，否则使用互斥锁</span>。


---


## 死锁发生条件是什么？

死锁只有在同时满足以下四个条件才会发生：
- 互斥条件： 互斥条件是指<span style="color: blue;">多个线程不能同时使用同一个资源</span>。
- 持有并等待条件： 持有并等待条件是指，当线程 A 已经持有了资源 1，又想申请资源 2，而资源 2 已经被线程 C 持有了，所以线程 A 就会处于等待状态，但是<span style="color: blue;">线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1</span>。
- 不可剥夺条件： 不可剥夺条件是指，当线程已经持有了资源，<span style="color: blue;">在自己使用完之前不能被其他线程获取</span>，线程 B 如果也想使用此资源，则只能在线程 A 使用完并释放后才能获取。
- 环路等待条件： 环路等待条件指的是，在死锁发生的时候，<span style="color: blue;">两个线程获取资源的顺序构成了环形链</span>。


---


## 讲一下银行家算法

系统发生死锁是很正常的，我们需要主动去预防死锁，即进行有序的资源分配，使用银行家算法。

银行家算法是最有代表性的避免死锁的算法。

为什么叫银行家算法呢？就是这个算法的逻辑很像银行放贷的逻辑，也就是尽可能避免坏账的出现。

银行家算法的业务逻辑如下。

- 不负荷执行： <span style="color: blue;">一个进程的最大需求量不超过系统拥有的总资源数</span>，才会被接纳执行。
- 可分期： 一个进程可以分期申请资源，但总请求书不可超过最大需求量。
- 推迟分配： 当系统现有资源数小于进程需求时，对进程的需求可以延迟分配，但总让进程在有限时间内获取资源。



