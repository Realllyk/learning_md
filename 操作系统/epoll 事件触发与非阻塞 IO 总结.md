
## 1. epoll 事件触发的作用
- 内核会监控已注册的文件描述符（fd）的状态变化。
- 当事件发生（如 socket 可读/可写），内核会把对应的 **fd 加入 epoll 的就绪链表**。
- 应用程序调用 `epoll_wait()` 时：
  - 如果链表为空 → 阻塞等待。
  - 如果链表非空 → 从链表中拷贝事件到用户空间，返回就绪事件的数量。

👉 **触发事件的作用**：让 fd 进入就绪链表，供 `epoll_wait()` 返回。

---

## 2. 水平触发 (LT) 与 边缘触发 (ET)

### 水平触发 (LT)
- 条件只要一直成立（如缓冲区有数据），fd 就会反复加入就绪链表。
- 如果应用没读完，下一次 `epoll_wait()` 仍会返回该 fd。
- **特点**：状态维持，只要没处理完，持续通知。

### 边缘触发 (ET)
- 只有状态变化的瞬间（如缓冲区从空变非空）才加入一次就绪链表。
- 如果应用没把数据一次性读完，下次 `epoll_wait()` 不会再返回该 fd，除非有新数据到来。
- **特点**：状态变化驱动，只提醒一次。

---

## 3. 阻塞 I/O 与非阻塞 I/O

### 阻塞 I/O
- `read(fd, buf, size)` 行为：
  - 如果数据不足 `size`，会阻塞等待更多数据或连接关闭。
  - 可能导致应用线程卡住。

### 非阻塞 I/O
- `read(fd, buf, size)` 行为：
  - 返回当前能读到的数据。
  - 如果没有数据，立即返回 `-1` 并设置 `errno = EAGAIN`。
- 需要应用在循环中一直读，直到遇到 `EAGAIN`，确保数据读完。

---

## 4. 为什么 ET 必须配合非阻塞 I/O
- ET 模式只在“状态变化”时通知一次。
- 如果使用阻塞 I/O：
  - 读数据时可能卡住，影响性能。
  - 或者因为没一次性读完，导致后续事件丢失。
- 使用非阻塞 I/O：
  - 每次事件触发时，在循环中把数据读到 `EAGAIN` 为止。
  - 确保不会丢事件，也不会阻塞线程。

**示例：**
```c
while ((n = read(fd, buf, sizeof(buf))) > 0) {
    // 处理数据
}
if (n == -1 && errno == EAGAIN) {
    // 数据读完，等待下一次 epoll_wait()
}
