## 进程与线程的区别

- **本质区别**：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。
- **在开销方面**：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。
- **稳定性方面**：<span style="color: blue;">进程中某个线程如果崩溃了，可能会导致整个进程都崩溃。而进程中的子进程崩溃，并不会影响其他进程</span>。
- **内存分配方面**：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程之间只能共享资源。
- **包含关系**：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则此过程是一个多线程的，而不是多进程。


----


## 线程上下文

### **线程上下文的组成**
线程的上下文主要包含 **CPU 寄存器状态** 和 **内存状态**：
1. **程序计数器（PC，Program Counter）**：记录当前线程执行到哪一条指令。
2. **通用寄存器**：保存线程的局部变量、计算中间值等。
3. **栈指针（Stack Pointer, SP）**：指向线程的调用栈，用于存储函数调用、返回地址、局部变量等。
4. **帧指针（Frame Pointer, FP）**：指向当前函数调用帧，管理栈结构。
5. **浮点寄存器**（如果涉及浮点运算）。
6. **线程调度相关信息**：如线程的优先级、运行状态等。
7. **内存映射**（主要是用户态线程）：
    - **代码段**（Text Segment）：指令所在的内存区域。
    - **数据段**（Data Segment）：线程使用的全局变量。
    - **堆（Heap）**：动态分配的内存。

### **线程恢复上下文的过程**
当一个线程从 **阻塞、挂起或调度切换回到运行状态**，操作系统会进行 **上下文恢复**：
1. **加载程序计数器（PC）**，恢复线程中断前的执行位置。
2. **恢复通用寄存器的值**，确保计算结果正确。
3. **恢复栈指针（SP）**，让线程能够正确管理调用栈。
4. **恢复帧指针（FP）**，保持函数调用栈的完整性。
5. **恢复浮点寄存器（如适用）**。
6. **恢复线程调度信息**，确保线程按照正确的优先级和调度策略执行。
7. **恢复内存状态（如涉及虚拟内存）**，确保线程访问正确的数据。


---


## 进程、线程、协程的区别

- **进程**：进程是操作系统中进行资源分的基本单位，它拥有自己的独立内存空间和系统资源。每个进程都有独立的堆和栈，不与其他进程共享。进程间通信需要通过特定的机制，如管道、消息队列、信号量等。由于进程拥有独立的内存空间，因此其稳定性和安全性相对较高，但同时上下文切换的开销较大，因为需要保存和恢复整个进程的状态。
- **线程**：线程是进程内的一个执行单元，也是CPU调度和分派的基本单位。与进程不同，线程共享进程的内存空间，包括堆和全局变量。线程之间通信开销较小，因为它们可以直接读写共享内存。线程的上下文切换开销较小，因为只需要保存和恢复线程的上下文，而不是整个进程的状态。然而，由于多个线程共享内存空间，因此数据竞争和线程安全问题，需要通过同步和互斥机制来解决。
- **协程**：协程是一种用户态的轻量级线程，其调度完全由用户程序控制，而不需要内核的参与。协程拥有自己的寄存器上下文和栈，但与其他线程共享堆内存。协程的切换开销非常小，因为只需要保存和恢复寄存器上下文，而无需涉及内核级的上下文切换。这使得协程在处理大量并发任务时具有非常高的效率。然而，协程需要手动显式地进行调度，相对于线程和进程来说，其编程模型更加复杂。

###  **线程与协程的关系**

- **线程（Thread）** 是 **操作系统调度的基本单位**，可以是**内核线程（Kernel Thread）** 也可以是 **用户线程（User Thread）**。
- **协程（Coroutine）** 是**完全运行在用户态的轻量级线程**，它的调度由**用户程序**控制，而不是由操作系统内核调度。

所以可以这样理解：
- **线程是由操作系统管理的，而协程是由应用程序自己管理的**。
- **协程通常运行在线程之上，它本质上是“用户态的线程”**，也就是说，协程依赖于线程运行，并且一个线程可以包含多个协程。

### **线程 vs. 协程**

| **对比项**   | **线程（Thread）**               | **协程（Coroutine）**                                      |
| --------- | ---------------------------- | ------------------------------------------------------ |
| **调度方式**  | 由 **操作系统（OS）** 调度            | 由 **用户程序** 自己调度                                        |
| **上下文切换** | 需要 **内核态与用户态** 切换，开销较大       | 纯**用户态切换**，开销极小                                        |
| **并行能力**  | 可以真正并行（多线程运行在多个 CPU 核心上）     | 不能真正并行（一个线程内的多个协程是**串行**执行的）                           |
| **资源占用**  | 每个线程需要分配独立的 **堆栈**（通常 1MB）   | 每个协程的 **堆栈** 只占用很少的空间（通常几 KB）                          |
| **使用方式**  | 适用于 CPU 密集型、多核计算             | 适用于 I/O 密集型、高并发任务                                      |
| **典型应用**  | 多线程并发编程（Java 线程、C++ pthread） | Golang goroutine、Python asyncio、JavaScript async/await |

 **线程与协程的运行方式**
- 线程可以同时运行多个（如果 CPU 核心足够，多线程可以真正并行执行）。
- 协程虽然可以在一个线程里切换执行多个任务，但它们 **不会同时运行**，它们是 **在一个线程的不同时间片内被手动调度**。


---

## 进程具体分配的资源有哪些

在操作系统中，**进程是系统分配资源的基本单位**，这里的 **资源** 主要包括以下几类：
### **1. CPU 时间（处理器资源）**
- 进程需要 CPU 执行指令，操作系统会为每个进程 **分配 CPU 时间片**，通过 **调度算法（如时间片轮转、优先级调度等）** 进行管理。

### **2. 内存（主存 RAM）**
- 每个进程都会被分配一定的 **独立地址空间**，包括：
    - **代码段**（Text Segment）：存放程序的可执行代码。
    - **数据段**（Data Segment）：存放全局变量、静态变量等。
    - **堆（Heap）**：存放动态分配的内存，如 `malloc()` 或 `new` 分配的内存。
    - **栈（Stack）**：用于存储函数调用信息、局部变量等。

### **3. I/O 设备（文件、网络等）**
- 进程可能需要访问 **硬盘（文件）、键盘、鼠标、网络接口等外部设备**，这些资源需要操作系统进行管理。
- 进程通过 **文件描述符（File Descriptor）** 访问文件或网络连接，例如：
    - 进程打开一个文件，会获得 **文件描述符**，然后才能读写文件。
    - 进程与网络通信时，需要 **分配端口** 并管理 **TCP/UDP 连接**。

### **4. 进程控制块（PCB，Process Control Block）**
- PCB 记录进程的所有状态信息，如：
    - 进程 ID（PID）
    - 进程状态（运行、就绪、阻塞等）
    - 程序计数器（PC）：指示当前执行的位置
    - CPU 寄存器
    - 打开的文件描述符等
- PCB 由操作系统维护，用于管理进程的调度、切换和资源分配。

### **5. 线程（Thread）**
- 进程可以包含多个线程，线程 **共享进程的内存和资源**。
- 线程的创建、切换和销毁通常比进程轻量级，但仍然受限于进程的资源。

### **6. 进程间通信（IPC）资源**
- 当多个进程需要协作时，操作系统提供进程间通信（IPC）机制：
    - **管道（Pipe）**
    - **共享内存（Shared Memory）**
    - **消息队列（Message Queue）**
    - **信号量（Semaphore）**
    - **套接字（Socket）**
- 这些机制允许进程 **安全地共享数据** 或 **进行同步**，防止资源冲突。

### **7. 进程的权限和安全信息**
- 每个进程都有 **用户 ID（UID）** 和 **组 ID（GID）**，用于访问控制。
- 操作系统通过 **访问控制列表（ACL）** 或 **权限位（如 Linux 的 `chmod`）** 限制进程对文件和设备的访问权限。


---


## **多线程是不是越多越好，太多会有什么问题？**

多线程不一定越多越好，过多的线程可能会导致一些问题。
- **切换开销**：线程的创建和切换会消耗系统资源，包括内存和 CPU。如果创建太多线程，会占用大量的系统资源，导致系统负载过高，某些线程响应慢，可能会导致进程崩溃。
- **死锁的问题**：过多的线程可能会导致竞争条件和死锁。竞争条件指的是多个线程同时访问和修改共享资源，如果没有合适的同步机制，可能会导致数据不一致或错误的结果。而死锁则是指多个线程相互等待对方释放资源，导致程序无法继续执行。


---

## **线程的切换消耗资源**

线程切换（上下文切换，Context Switch）是指**从一个线程切换到另一个线程**，这个过程需要**操作系统进行调度，并保存/恢复线程的执行状态**，主要消耗 **CPU 和内存**。

### **线程切换开销来源**

1. **保存和恢复 CPU 寄存器**：
    - 线程切换时，操作系统必须**保存当前线程的寄存器状态（如 PC、SP、通用寄存器）**，然后恢复下一个线程的寄存器状态。
    - 这些数据存放在 **线程控制块（TCB）** 中。
2. **切换栈指针**：
    - 线程的栈是独立的，因此**切换线程时，操作系统需要修改栈指针（Stack Pointer, SP）**，确保新的线程能正确执行。
3. **CPU 调度**：
    - 操作系统的调度器（Scheduler）**需要运行计算哪个线程应该获得 CPU 资源**，并更新调度队列。
    - 复杂的调度策略（如**优先级调度、多级反馈队列**）会增加 CPU 负担。
4. **可能涉及用户态与内核态切换**：
    - **线程切换时，如果涉及内核调度（如 I/O 阻塞、锁竞争），可能会导致用户态与内核态的切换（Mode Switch），进一步增加开销**。
    - **用户态 -> 内核态 -> 另一个线程的用户态**，这个过程需要 CPU 执行多个额外的指令。


---


# 进程切换和线程切换的区别

1. **进程切换**：进程切换涉及到更多的内容，包括整个进程的地址空间、全局变量、文件描述符等。因此，进程切换的开销通常比线程切换大。
2. **线程切换**：线程切换只涉及到线程的堆栈、寄存器和程序计数器等，不涉及进程级别的资源，因此线程切换的开销较小。


---


### **TCB 和 PCB 的关系**

| **属性**      | **PCB（进程控制块）**      | **TCB（线程控制块）**      |
| ----------- | ------------------- | ------------------- |
| **管理对象**    | 整个进程                | 进程中的线程              |
| **唯一标识**    | 进程 ID（PID）          | 线程 ID（TID）          |
| **存储位置**    | 内核                  | 内核（内核线程）或用户态（用户线程）  |
| **内存管理**    | 记录整个进程的**地址空间、页表**等 | **不涉及**，线程共享进程的地址空间 |
| **CPU 寄存器** | 记录整个进程的 CPU 状态      | 记录**线程**的 CPU 状态    |
| **调度信息**    | 进程的调度优先级、调度策略       | 线程的调度信息             |
| **资源管理**    | 文件、网络、设备、内存         | 线程的栈、寄存器、同步信息       |

📌 **总结**
- **TCB 主要存储线程级别的信息，如寄存器、栈指针、线程 ID、状态、调度信息**。
- **PCB 存储进程级别的信息，如地址空间、全局变量、文件描述符等**。
- **多个线程共享进程的 PCB，但每个线程都有自己的 TCB**。


---




# 线程切换的详细过程

线程切换的详细过程可以分为以下几个步骤：

- **上下文保存**：当操作系统决定切换到另一个线程时，它首先会保存当前线程的上下文信息。上下文信息包括寄存器状态、程序计数器、堆指针等，用于保存线程的执行状态。
- **切换到调度器**：操作系统将执行权切换到调度器（Scheduler）。调度器负责选择下一个要执行的线程，并根据调度算法做出决策。
- **上下文恢复**：调度器选择了下一个要执行的线程后，它会从该线程保存的上下文信息中恢复线程的执行状态。
- **切换到新线程**：调度器将执行权切换到新线程，使其开始执行。

上下文信息的保存通常由操作系统负责管理，具体保存在哪取决于操作系统的实现方式。一般情况下，上下文信息会保存在线程的控制块（Thread Control Block，TCB）中。

TCB 是操作系统用于管理线程的**数据结构**，包含线程的状态、寄存器的信息、栈信息等。当发生线程切换时，操作系统会通过切换 TCB 来保存和恢复线程的上下文信息。


---


## 进程的五种状态变迁

![[process_status.webp]]

进程的状态变化如下：
- **NULL -> 创建状态**：一个新进程被创建时的第一个状态。
- **创建状态 -> 就绪状态**：当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态，这个过程是很快的。
- **就绪状态 -> 运行状态**：处于就绪状态的进程被操作系统的进程调度器选中后，就分配给 CPU 正式运行该进程。
- **运行状态 -> 结束状态**：当进程已经运行完成或出现错误，会被操作系统作结束状态处理。
- **运行状态 -> 就绪状态**：处于运行状态的进程在运行过程中，由于分配给它的运行时间片用完，操作系统会把该进程变为就绪状态，然后从就绪状态中另选一个进程运行。
- **运行状态 -> 阻塞状态**：当进程请求某个事件但必须等待时，例如请求 I/O 事件。
- **阻塞状态 -> 就绪状态**：当进程要等待的事件完成时，它从阻塞状态变到就绪状态。


---


# 进程上下文有哪些？

各个进程之间是共享 CPU 资源的，在不同的时刻进程之间需要切换，让不同的进程可以在 CPU 执行，那么**一个进程切换到另一个进程运行，称为进程的上下文切换**。

### **CPU 上下文切换**
在详细说明进程上下文切换前，我们先来看 CPU 上下文。
大多数操作系统都是多任务，通常支持大于 CPU 数量的任务同时运行。实际上，这些任务并不是同时运行的，只是因为系统在很短的时间内，让各个任务分别在 CPU 运行，于是就造成同时运行的假象。
任务是交给 CPU 运行的，那么在每个任务运行前，CPU 需要知道任务从哪里加载，又从哪里开始运行。
所以，操作系统需要事先为 CPU 设立好**寄存器和程序计数器**。
- **CPU 寄存器**：CPU 内部的高速缓存，用于存储计算过程中的数据。
- **程序计数器（PC）**：存储 CPU 当前执行的指令地址。

当任务切换时，CPU 上下文信息（寄存器和程序计数器）会被保存，新的任务加载时会恢复这些信息，以保证任务继续执行。

### **进程上下文切换**

进程是由内核管理和调度的，所以进程的切换只能发生在内核态。

因此，**进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核栈、寄存器等内核空间的资源。**

通常，操作系统会将交换的信息存储在进程的 **PCB（进程控制块）** 中。当 CPU 需要执行另一个进程时，操作系统会从当前进程的 PCB 取出上下文信息，保存，并从另一个进程的 PCB 恢复上下文信息，以便 CPU 可以继续执行新的进程。

![[process_context.webp]]

---


## 进程上下文与 PCB

进程上下文（Process Context）是操作系统切换进程时需要保存和恢复的信息，它包括用户态和内核态的资源。

### **1. 进程上下文的组成**
进程上下文主要包括以下部分：
#### **（1）用户态上下文（User Context）**
- **虚拟地址空间**
    - 代码段（Text Segment）：存储进程的可执行代码
    - 数据段（Data Segment）：存储全局变量、静态变量
    - 堆（Heap）：动态分配的内存，如 `malloc()`、`new`
    - 栈（Stack）：存储局部变量、函数调用信息
- **进程控制信息**
    - 进程 ID（PID）
    - 进程状态（就绪、运行、阻塞、终止）
    - 进程优先级
    - 进程所属用户和组

#### **（2）内核态上下文（Kernel Context）**
- **CPU 寄存器状态**
    - **通用寄存器**（存储计算数据）
    - **程序计数器（PC）**（指向当前执行的指令）
    - **栈指针（SP）**（指向进程的内核栈）
    - **状态寄存器**（保存 CPU 运行状态）
- **内核栈**
    - 每个进程有一个**内核栈**，用于处理系统调用、异常和中断
- **内存管理信息**
    - 页表（Page Table）：映射进程的虚拟地址到物理地址
    - 段表（Segment Table）：管理代码段、数据段、堆和栈
- **文件描述符表**
    - 记录进程打开的文件（如 `stdin`、`stdout`、`stderr`）
### **2. PCB（进程控制块）**
PCB（Process Control Block）是操作系统管理进程的核心数据结构，存储进程的关键信息。

#### **PCB 包含的信息**
- **进程 ID（PID）、父进程 ID（PPID）**
- **进程状态**（就绪、运行、阻塞等）
- **CPU 寄存器快照**（用于进程切换）
- **进程优先级**
- **进程打开的文件（文件描述符表）**
- **内存管理信息（页表、段表）**
- **信号处理信息（如** `**SIGKILL**`**、**`**SIGSTOP**`**）**

### **3. 进程上下文切换的具体步骤**
1. **保存当前进程的 CPU 上下文**
    - 将 CPU 寄存器、程序计数器、栈指针等数据保存到该进程的 PCB
    - 切换到内核态，更新内核堆栈

2. **更新内存管理信息**
    - 切换页表，映射新的进程地址空间
    - 确保新的进程能够访问正确的代码、数据和堆栈
3. **恢复目标进程的 CPU 上下文**
    - 从目标进程的 PCB 读取寄存器状态
    - 恢复程序计数器，使进程继续执行

### **4. 结论**
- **进程上下文 ≠ PCB**，PCB 只是进程上下文的一部分。
- **进程上下文 = 用户态上下文 + 内核态上下文**，包括虚拟内存、寄存器、页表、文件描述符等。
- **进程上下文切换时，操作系统需要保存当前进程的状态，并加载新进程的状态，确保新进程能够正确运行。**


---

## 进程间通信方式

Linux 内核提供了不少进程间通信的方式：
- **管道（Pipe）**
- **消息队列（Message Queue）**
- **共享内存（Shared Memory）**
- **信号（Signal）**
- **信号量（Semaphore）**
- **Socket 通信**

### **1. 管道（Pipe）**
管道是一种最简单的进程间通信方式，分为 **匿名管道（Unnamed Pipe）** 和 **命名管道（Named Pipe，FIFO）**。<span style="color: blue;">通信的数据是无格式的流并且大小受限。</span>
- **匿名管道**：只能用于父子进程间通信，数据单向流动，生命周期随进程结束。 
- **命名管道**：可以在不相关的进程间通信，支持文件系统中的特殊文件，数据采用**先进先出（FIFO）** 模式。
### **2. 消息队列（Message Queue）**
消息队列克服了管道数据格式不固定的缺点，数据以**独立消息体**的方式存储在内核，支持进程间**异步通信**。消息体可以是用户自定义的数据类型。消息队列通信的速度不是最及时的，<span style="color: blue;">毕竟每次数据的写入和读取都需要经过用户态和内核态之间的拷贝</span>。

- **消息队列在每种类型内部是 FIFO**；
- ❌ 不同类型之间不能保证全局 FIFO 顺序；
- ❓ 读取时如果找不到指定类型，是否阻塞由 `msgflg` 决定；
	- 如果没有指定 `IPC_NOWAIT`：**系统会阻塞等待**，直到有匹配的消息进来。
	- 如果指定了 `IPC_NOWAIT`：**不会阻塞**，直接返回 `-1`，并设置 `errno = ENOMSG`（表示没有匹配消息）。
- 🚫 不存在“读错结构”的情况——因为读取数据前你自己提供了结构定义（`msgbuf`），但**你要确保接收端定义的结构和发送端一致**，否则会发生数据错乱。

### **3. 共享内存（Shared Memory）**
共享内存允许多个进程**直接访问同一块内存区域**，极大提高了通信速度，但需要**同步机制**（如信号量）避免数据竞争。

共享内存的即使，就是拿出一块虚拟地址空间，映射到相同的物理内存中。这样这个进程写入的东西，另一个进程马上就能看到，不需要传输。

![[shared_memory.webp]]

### **4. 信号量（Semaphore）**
信号量是一种**计数器机制**，用于控制多个进程对共享资源的访问，支持**进程同步**。支持P操作和V操作。
- **P 操作（proberen，尝试/等待，Wait）**
	- **作用**：**减少信号量的值**，如果值小于 0，则 **阻塞** 进程，直到信号量变为正数。
	- **表示进程请求资源**，如果资源可用（信号量 > 0），则继续执行；如果资源不可用（信号量 = 0），则阻塞等待。
-  **V 操作（verhogen，增加，Signal）**
	- **作用**：**增加信号量的值**，如果值小于等于 0，唤醒等待的进程。
	- **表示进程释放资源**，如果有等待的进程，则唤醒它。

### **5. 信号（Signal）**
信号是一种**异步通知机制**，可以用于进程间通信或通知进程发生某个事件，如 `SIGKILL` 终止进程。

### **6. Socket 通信**
Socket 适用于**同一主机或不同主机**的进程通信，支持 **TCP** 和 **UDP** 协议，主要用于 **网络通信**。


---


## 线程间通信方式

Linux 提供了多种线程通信的方式：
- **互斥锁（Mutex）**
- **条件变量（Condition Variables）**
- **自旋锁（Spinlock）**
- **信号量（Semaphore）**
- **读写锁（Read-Write Lock）**

### **1. 互斥锁（Mutex）**

- 互斥量（mutex）是一种锁机制，**用于防止多个线程同时访问共享资源**。
- 当一个线程获取互斥锁后，其他试图获取该锁的线程会被阻塞，直到锁被释放。
- 互斥锁适用于**线程间的互斥访问**，避免数据竞争问题。

### **2. 条件变量（Condition Variables）**
- 条件变量（cond）**用于线程间的等待-通知机制**，适用于**需要等待特定条件**发生的场景。
- 一个线程调用 `pthread_cond_wait()` 进入等待状态，另一个线程调用 `pthread_cond_signal()` 唤醒等待线程。
- 条件变量通常**与互斥锁配合使用**，以防止竞争条件。

### **3. 自旋锁（Spinlock）**
- 自旋锁是一种轻量级的锁，**线程在获取锁时不会进入睡眠，而是循环等待，直到锁可用**。
- 适用于**锁占用时间极短**的场景，例如**内核同步**。
- 与互斥锁不同，**自旋锁不会导致线程调度**，因此在高并发情况下可能比互斥锁更高效。

### **4. 信号量（Semaphore）**
- 信号量可用于**线程同步和资源管理**。
- **P 操作（Wait）**：信号量减 1，若信号量 ≤ 0，则进程阻塞。
- **V 操作（Signal）**：信号量加 1，若信号量 ≤ 0，则唤醒等待的线程。
- 适用于**多线程访问有限资源**的场景，如**生产者-消费者模型**。

### **5. 读写锁（Read-Write Lock）**
- 读写锁（RWLock）区分**读锁和写锁**，适用于**读多写少**的场景。
- **多个线程可以同时持有读锁**，但**写锁是独占的**，写锁会阻塞读操作。
- 读写锁适用于**多线程访问共享数据**时，**读多写少的情况更优**。


---


## 进程调度算法有哪些？

### **先来先服务调度算法（First Come First Served, FCFS）**
先来先服务（FCFS）调度算法是最简单的非抢占式调度算法。它的基本思想是按照进程到达的先后顺序进行调度。

- 规则：每次从就绪队列中选择**最先进入队列的进程**执行，直到进程退出或被阻塞，再继续选择下一个进程。
- **优点**：公平，适用于 CPU 密集型任务。
- **缺点**：对长作业有利，但短作业可能会等待很长时间（可能导致“**短作业饥饿**”）。
- **适用场景**：CPU 密集型系统。

![[FIFS.webp]]

### **最短作业优先调度算法（Shortest Job First, SJF）**

最短作业优先（SJF）调度算法按照进程的 **运行时间长短** 进行调度。

- 规则：每次调度时，优先选择运行时间最短的进程。
- **优点**：提高系统的吞吐量，减少平均等待时间。
- **缺点**：对长作业不利，可能造成长作业饥饿。
- **适用场景**：适用于**需要最小化等待时间**的系统。

![[SJF.webp]]

### **高响应比优先调度算法（Highest Response Ratio Next, HRRN）**

高响应比优先调度算法 **综合考虑等待时间和作业执行时间**，以**避免短作业优先算法导致长作业饥饿的问题**。

![[Highest_Response_Ratio.webp]]

- 规则：每次调度时，计算进程的“**响应比优先级**”
    **公式**：
    - **如果等待时间相同**，则需要时间短的进程优先运行。
    - **如果服务时间相同**，则等待时间长的进程优先运行。

- **优点**：兼顾长短作业，防止短作业优先策略中的长作业饥饿问题。
- **缺点**：计算复杂度稍高。
- **适用场景**：适用于**需要平衡长短作业公平性**的系统。

### **时间片轮转调度算法（Round Robin, RR）**

时间片轮转调度算法是一种**最公平、最常用的调度算法**。

![[Round_Robbin.webp]]

- 规则：
    - 每个进程被分配一个**时间片（Quantum）**，允许该进程运行该时间片的时间。
    - **如果时间片用完**，进程仍未完成，则被挂起，CPU 分配给下一个进程。
    - **如果进程在时间片结束前阻塞或完成**，则 CPU 立即切换。
- **优点**：
    - 所有进程在**循环中得到公平调度**。
    - **适用于多用户环境**。
- **缺点**：
    - 如果时间片太短，切换开销大，降低 CPU 效率。
    - 如果时间片太长，系统可能会退化为 FCFS。
- **时间片通常设定在 20ms~50ms 之间**，是 CPU 调度的重要参数。

### **最高优先级调度算法（Highest Priority First, HPF）**

最高优先级调度算法根据进程的 **优先级** 进行调度。
- 规则：从就绪队列中选择**优先级最高的进程**运行。
- **优先级类型**：
    - **静态优先级**：进程创建时确定，运行期间不变。
    - **动态优先级**：根据进程运行状态动态调整，等待时间增加时提高优先级。
- **调度方式**：
    - **非抢占式**：当前进程运行完毕后才调度下一个优先级高的进程。
    - **抢占式**：若有更高优先级进程到达，立刻抢占 CPU 进行调度。
- **缺点**：可能会导致**优先级低的进程长期等待（饥饿问题）**。

### **多级反馈队列调度算法（Multilevel Feedback Queue, MLFQ）**

![[multi_level_feedback.webp]]

多级反馈队列调度算法是**时间片轮转调度**与**优先级调度**的结合体。

- 规则：
    - 进程根据**优先级**进入不同级别的队列。
    - **优先级高的队列**分配**更短的时间片**。
    - **如果进程运行时间过长**，会被移动到更低优先级的队列。
    - **短作业在高优先级队列中快速执行**，长作业逐渐降低优先级。
- **优点**：
    - 适用于**兼顾短作业和长作业**的调度需求。
    - 短作业可以快速执行，长作业最终也能得到运行机会。
- **缺点**：
    - 需要更复杂的调度策略和多个就绪队列。

对于短作业，可能可以在第一级队列很快被处理完。
对于长作业，如果在第一级队列处理不完，可以移入下一次队列等待被执行，虽然等待的时间变长，但是运行时间也会更长，所以该算法很好的兼顾了长短作业。


## **总结：不同调度算法的对比**

|调度算法|方式|适用场景|优点|缺点|
|---|---|---|---|---|
|**FCFS**|非抢占|CPU 密集型|简单、公平|短作业等待时间长|
|**SJF**|非抢占|最小化等待时间|平均等待时间短|长作业可能饥饿|
|**HRRN**|非抢占|兼顾长短作业|解决 SJF 饥饿问题|计算复杂|
|**RR**|抢占|多用户、公平性高|适合多任务系统|时间片设定需权衡|
|**HPF**|抢占/非抢占|需要优先级管理|高优先级进程先执行|低优先级进程可能饥饿|
|**MLFQ**|抢占|兼顾长短作业|动态调整优先级，适用于多任务|实现复杂|


---


