## 进程与线程的区别

- **本质区别**：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。
- **在开销方面**：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。
- **稳定性方面**：<span style="color: blue;">进程中某个线程如果崩溃了，可能会导致整个进程都崩溃。而进程中的子进程崩溃，并不会影响其他进程</span>。
- **内存分配方面**：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程之间只能共享资源。
- **包含关系**：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则此过程是一个多线程的，而不是多进程。


----


## 线程上下文

### **线程上下文的组成**
线程的上下文主要包含 **CPU 寄存器状态** 和 **内存状态**：
1. **程序计数器（PC，Program Counter）**：记录当前线程执行到哪一条指令。
2. **通用寄存器**：保存线程的局部变量、计算中间值等。
3. **栈指针（Stack Pointer, SP）**：指向线程的调用栈，用于存储函数调用、返回地址、局部变量等。
4. **帧指针（Frame Pointer, FP）**：指向当前函数调用帧，管理栈结构。
5. **浮点寄存器**（如果涉及浮点运算）。
6. **线程调度相关信息**：如线程的优先级、运行状态等。
7. **内存映射**（主要是用户态线程）：
    - **代码段**（Text Segment）：指令所在的内存区域。
    - **数据段**（Data Segment）：线程使用的全局变量。
    - **堆（Heap）**：动态分配的内存。

### **线程恢复上下文的过程**
当一个线程从 **阻塞、挂起或调度切换回到运行状态**，操作系统会进行 **上下文恢复**：
1. **加载程序计数器（PC）**，恢复线程中断前的执行位置。
2. **恢复通用寄存器的值**，确保计算结果正确。
3. **恢复栈指针（SP）**，让线程能够正确管理调用栈。
4. **恢复帧指针（FP）**，保持函数调用栈的完整性。
5. **恢复浮点寄存器（如适用）**。
6. **恢复线程调度信息**，确保线程按照正确的优先级和调度策略执行。
7. **恢复内存状态（如涉及虚拟内存）**，确保线程访问正确的数据。


---


## 进程、线程、协程的区别

- **进程**：进程是操作系统中进行资源分的基本单位，它拥有自己的独立内存空间和系统资源。每个进程都有独立的堆和栈，不与其他进程共享。进程间通信需要通过特定的机制，如管道、消息队列、信号量等。由于进程拥有独立的内存空间，因此其稳定性和安全性相对较高，但同时上下文切换的开销较大，因为需要保存和恢复整个进程的状态。
- **线程**：线程是进程内的一个执行单元，也是CPU调度和分派的基本单位。与进程不同，线程共享进程的内存空间，包括堆和全局变量。线程之间通信开销较小，因为它们可以直接读写共享内存。线程的上下文切换开销较小，因为只需要保存和恢复线程的上下文，而不是整个进程的状态。然而，由于多个线程共享内存空间，因此数据竞争和线程安全问题，需要通过同步和互斥机制来解决。
- **协程**：协程是一种用户态的轻量级线程，其调度完全由用户程序控制，而不需要内核的参与。协程拥有自己的寄存器上下文和栈，但与其他线程共享堆内存。协程的切换开销非常小，因为只需要保存和恢复寄存器上下文，而无需涉及内核级的上下文切换。这使得协程在处理大量并发任务时具有非常高的效率。然而，协程需要手动显式地进行调度，相对于线程和进程来说，其编程模型更加复杂。

###  **线程与协程的关系**

- **线程（Thread）** 是 **操作系统调度的基本单位**，可以是**内核线程（Kernel Thread）** 也可以是 **用户线程（User Thread）**。
- **协程（Coroutine）** 是**完全运行在用户态的轻量级线程**，它的调度由**用户程序**控制，而不是由操作系统内核调度。

所以可以这样理解：
- **线程是由操作系统管理的，而协程是由应用程序自己管理的**。
- **协程通常运行在线程之上，它本质上是“用户态的线程”**，也就是说，协程依赖于线程运行，并且一个线程可以包含多个协程。

### **线程 vs. 协程**

| **对比项**   | **线程（Thread）**               | **协程（Coroutine）**                                      |
| --------- | ---------------------------- | ------------------------------------------------------ |
| **调度方式**  | 由 **操作系统（OS）** 调度            | 由 **用户程序** 自己调度                                        |
| **上下文切换** | 需要 **内核态与用户态** 切换，开销较大       | 纯**用户态切换**，开销极小                                        |
| **并行能力**  | 可以真正并行（多线程运行在多个 CPU 核心上）     | 不能真正并行（一个线程内的多个协程是**串行**执行的）                           |
| **资源占用**  | 每个线程需要分配独立的 **堆栈**（通常 1MB）   | 每个协程的 **堆栈** 只占用很少的空间（通常几 KB）                          |
| **使用方式**  | 适用于 CPU 密集型、多核计算             | 适用于 I/O 密集型、高并发任务                                      |
| **典型应用**  | 多线程并发编程（Java 线程、C++ pthread） | Golang goroutine、Python asyncio、JavaScript async/await |

 **线程与协程的运行方式**
- 线程可以同时运行多个（如果 CPU 核心足够，多线程可以真正并行执行）。
- 协程虽然可以在一个线程里切换执行多个任务，但它们 **不会同时运行**，它们是 **在一个线程的不同时间片内被手动调度**。


---

## 进程具体分配的资源有哪些

在操作系统中，**进程是系统分配资源的基本单位**，这里的 **资源** 主要包括以下几类：
### **1. CPU 时间（处理器资源）**
- 进程需要 CPU 执行指令，操作系统会为每个进程 **分配 CPU 时间片**，通过 **调度算法（如时间片轮转、优先级调度等）** 进行管理。

### **2. 内存（主存 RAM）**
- 每个进程都会被分配一定的 **独立地址空间**，包括：
    - **代码段**（Text Segment）：存放程序的可执行代码。
    - **数据段**（Data Segment）：存放全局变量、静态变量等。
    - **堆（Heap）**：存放动态分配的内存，如 `malloc()` 或 `new` 分配的内存。
    - **栈（Stack）**：用于存储函数调用信息、局部变量等。

### **3. I/O 设备（文件、网络等）**
- 进程可能需要访问 **硬盘（文件）、键盘、鼠标、网络接口等外部设备**，这些资源需要操作系统进行管理。
- 进程通过 **文件描述符（File Descriptor）** 访问文件或网络连接，例如：
    - 进程打开一个文件，会获得 **文件描述符**，然后才能读写文件。
    - 进程与网络通信时，需要 **分配端口** 并管理 **TCP/UDP 连接**。

### **4. 进程控制块（PCB，Process Control Block）**
- PCB 记录进程的所有状态信息，如：
    - 进程 ID（PID）
    - 进程状态（运行、就绪、阻塞等）
    - 程序计数器（PC）：指示当前执行的位置
    - CPU 寄存器
    - 打开的文件描述符等
- PCB 由操作系统维护，用于管理进程的调度、切换和资源分配。

### **5. 线程（Thread）**
- 进程可以包含多个线程，线程 **共享进程的内存和资源**。
- 线程的创建、切换和销毁通常比进程轻量级，但仍然受限于进程的资源。

### **6. 进程间通信（IPC）资源**
- 当多个进程需要协作时，操作系统提供进程间通信（IPC）机制：
    - **管道（Pipe）**
    - **共享内存（Shared Memory）**
    - **消息队列（Message Queue）**
    - **信号量（Semaphore）**
    - **套接字（Socket）**
- 这些机制允许进程 **安全地共享数据** 或 **进行同步**，防止资源冲突。

### **7. 进程的权限和安全信息**
- 每个进程都有 **用户 ID（UID）** 和 **组 ID（GID）**，用于访问控制。
- 操作系统通过 **访问控制列表（ACL）** 或 **权限位（如 Linux 的 `chmod`）** 限制进程对文件和设备的访问权限。


---


## **多线程是不是越多越好，太多会有什么问题？**

多线程不一定越多越好，过多的线程可能会导致一些问题。
- **切换开销**：线程的创建和切换会消耗系统资源，包括内存和 CPU。如果创建太多线程，会占用大量的系统资源，导致系统负载过高，某些线程响应慢，可能会导致进程崩溃。
- **死锁的问题**：过多的线程可能会导致竞争条件和死锁。竞争条件指的是多个线程同时访问和修改共享资源，如果没有合适的同步机制，可能会导致数据不一致或错误的结果。而死锁则是指多个线程相互等待对方释放资源，导致程序无法继续执行。


---

## **线程的切换消耗资源**

线程切换（上下文切换，Context Switch）是指**从一个线程切换到另一个线程**，这个过程需要**操作系统进行调度，并保存/恢复线程的执行状态**，主要消耗 **CPU 和内存**。

### **线程切换开销来源**

1. **保存和恢复 CPU 寄存器**：
    - 线程切换时，操作系统必须**保存当前线程的寄存器状态（如 PC、SP、通用寄存器）**，然后恢复下一个线程的寄存器状态。
    - 这些数据存放在 **线程控制块（TCB）** 中。
2. **切换栈指针**：
    - 线程的栈是独立的，因此**切换线程时，操作系统需要修改栈指针（Stack Pointer, SP）**，确保新的线程能正确执行。
3. **CPU 调度**：
    - 操作系统的调度器（Scheduler）**需要运行计算哪个线程应该获得 CPU 资源**，并更新调度队列。
    - 复杂的调度策略（如**优先级调度、多级反馈队列**）会增加 CPU 负担。
4. **可能涉及用户态与内核态切换**：
    - **线程切换时，如果涉及内核调度（如 I/O 阻塞、锁竞争），可能会导致用户态与内核态的切换（Mode Switch），进一步增加开销**。
    - **用户态 -> 内核态 -> 另一个线程的用户态**，这个过程需要 CPU 执行多个额外的指令。


---


# 进程切换和线程切换的区别

1. **进程切换**：进程切换涉及到更多的内容，包括整个进程的地址空间、全局变量、文件描述符等。因此，进程切换的开销通常比线程切换大。
2. **线程切换**：线程切换只涉及到线程的堆栈、寄存器和程序计数器等，不涉及进程级别的资源，因此线程切换的开销较小。


---


### **TCB 和 PCB 的关系**

| **属性**      | **PCB（进程控制块）**      | **TCB（线程控制块）**      |
| ----------- | ------------------- | ------------------- |
| **管理对象**    | 整个进程                | 进程中的线程              |
| **唯一标识**    | 进程 ID（PID）          | 线程 ID（TID）          |
| **存储位置**    | 内核                  | 内核（内核线程）或用户态（用户线程）  |
| **内存管理**    | 记录整个进程的**地址空间、页表**等 | **不涉及**，线程共享进程的地址空间 |
| **CPU 寄存器** | 记录整个进程的 CPU 状态      | 记录**线程**的 CPU 状态    |
| **调度信息**    | 进程的调度优先级、调度策略       | 线程的调度信息             |
| **资源管理**    | 文件、网络、设备、内存         | 线程的栈、寄存器、同步信息       |

📌 **总结**
- **TCB 主要存储线程级别的信息，如寄存器、栈指针、线程 ID、状态、调度信息**。
- **PCB 存储进程级别的信息，如地址空间、全局变量、文件描述符等**。
- **多个线程共享进程的 PCB，但每个线程都有自己的 TCB**。


---




# 线程切换的详细过程

线程切换的详细过程可以分为以下几个步骤：

- **上下文保存**：当操作系统决定切换到另一个线程时，它首先会保存当前线程的上下文信息。上下文信息包括寄存器状态、程序计数器、堆指针等，用于保存线程的执行状态。
- **切换到调度器**：操作系统将执行权切换到调度器（Scheduler）。调度器负责选择下一个要执行的线程，并根据调度算法做出决策。
- **上下文恢复**：调度器选择了下一个要执行的线程后，它会从该线程保存的上下文信息中恢复线程的执行状态。
- **切换到新线程**：调度器将执行权切换到新线程，使其开始执行。

上下文信息的保存通常由操作系统负责管理，具体保存在哪取决于操作系统的实现方式。一般情况下，上下文信息会保存在线程的控制块（Thread Control Block，TCB）中。

TCB 是操作系统用于管理线程的**数据结构**，包含线程的状态、寄存器的信息、栈信息等。当发生线程切换时，操作系统会通过切换 TCB 来保存和恢复线程的上下文信息。


---


## 进程的五种状态变迁

![[process_status.webp]]

进程的状态变化如下：
- **NULL -> 创建状态**：一个新进程被创建时的第一个状态。
- **创建状态 -> 就绪状态**：当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态，这个过程是很快的。
- **就绪状态 -> 运行状态**：处于就绪状态的进程被操作系统的进程调度器选中后，就分配给 CPU 正式运行该进程。
- **运行状态 -> 结束状态**：当进程已经运行完成或出现错误，会被操作系统作结束状态处理。
- **运行状态 -> 就绪状态**：处于运行状态的进程在运行过程中，由于分配给它的运行时间片用完，操作系统会把该进程变为就绪状态，然后从就绪状态中另选一个进程运行。
- **运行状态 -> 阻塞状态**：当进程请求某个事件但必须等待时，例如请求 I/O 事件。
- **阻塞状态 -> 就绪状态**：当进程要等待的事件完成时，它从阻塞状态变到就绪状态。


---


# 进程上下文有哪些？

各个进程之间是共享 CPU 资源的，在不同的时刻进程之间需要切换，让不同的进程可以在 CPU 执行，那么**一个进程切换到另一个进程运行，称为进程的上下文切换**。

### **CPU 上下文切换**
在详细说明进程上下文切换前，我们先来看 CPU 上下文切换。
大多数操作系统都是多任务，通常支持大于 CPU 数量的任务同时运行。实际上，这些任务并不是同时运行的，只是因为系统在很短的时间内，让各个任务分别在 CPU 运行，于是就造成同时运行的假象。
任务是交给 CPU 运行的，那么在每个任务运行前，CPU 需要知道任务从哪里加载，又从哪里开始运行。
所以，操作系统需要事先为 CPU 设立好**寄存器和程序计数器**。
- **CPU 寄存器**：CPU 内部的高速缓存，用于存储计算过程中的数据。
- **程序计数器（PC）**：存储 CPU 当前执行的指令地址。

当任务切换时，CPU 上下文信息（寄存器和程序计数器）会被保存，新的任务加载时会恢复这些信息，以保证任务继续执行。

### **进程上下文切换**

进程是由内核管理和调度的，所以进程的切换只能发生在内核态。

因此，**进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。**

通常，操作系统会将交换的信息存储在进程的 **PCB（进程控制块）** 中。当 CPU 需要执行另一个进程时，操作系统会从当前进程的 PCB 取出上下文信息，保存，并从另一个进程的 PCB 恢复上下文信息，以便 CPU 可以继续执行新的进程。

![[process_context.webp]]
