## Http报文
![[http_segment.png]]
### 请求报文
- **请求行**：包含请求方法、请求目标（URL 或 URI）和 HTTP 协议版本。
- **请求头部**：包含关于请求的附加信息，如 Host、User-Agent、Content-Type 等。
- **空行**：请求头部和请求体之间用空行分隔。
- **请求体**：可选，包含请求的数据，通常用于 POST 请求等需要传输数据的情况。

### 响应报文
- **状态行**：包含 HTTP 协议版本、状态码和状态信息。
- **响应头部**：包含关于响应的附加信息，如 Content-Type、Content-Length 等。
- **空行**：响应头部和响应体之间用空行分隔。
- **响应体**：包含响应的数据，通常是服务器返回的 HTML、JSON 等内容。



---


## Http状态码
HTTP 状态码分为 5 大类：
- **1xx** 类状态码属于 **提示信息**，是协议处理中的一种中间状态，实际用到的比较少。
- **2xx** 类状态码表示服务器 **成功** 处理了客户端的请求，也是我们最愿意看到的状态。
- **3xx** 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是 **重定向**。
- **4xx** 类状态码表示客户端发送 **报文有误**，服务器无法处理，也就是错误的含义。
- **5xx** 类状态码表示客户端报文正确，但是 **服务器处理时内部发生了错误**，属于服务器端的错误码。

### 常见的具体状态码：
- **200**：请求成功。
- **301**：永久重定向； **302**：临时重定向。
- **404**：无法找到对应页面。
- **405**：请求的方法类型不支持。
- **500**：服务器内部错误。

### HTTP 返回状态 301 和 302 的区别

3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是 **重定向**。
- **301 Moved Permanently**：表示永久重定向，说明请求的资源已经不存在了，需要改用新的 URL 重新访问。
- **302 Found**：表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。
301 和 302 都会在响应头里使用字段 `Location`，指明后续要跳转的 URL，浏览器会自动重定向到新的 URL。

### HTTP 502 和 504 的区别
- **502 Bad Gateway**：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。
- **504 Gateway Time-out**：作为网关或代理工作的服务器尝试执行请求时，未能及时从上游服务器收到响应。

举一个例子，假设 nginx 是代理服务器，收到客户端的请求后，将请求转发到后端服务器（如 Tomcat）。
- 当 nginx 收到了无效的响应时，就返回 **502**。
- 当 nginx 超过自己配置的超时时间，还没有收到请求时，就返回 **504** 错误


## Http长连接
HTTP 协议采用的是「请求-应答」的模式，也就是客户端发起了请求，服务端才会返回响应，一来一回这样的交互方式。

由于 HTTP 是基于 TCP 传输协议实现的，客户端与服务端要进行 HTTP 通信前，需要先建立 TCP 连接，然后客户端发送 HTTP 请求，服务端收到后就返回响应，至此「请求-应答」的模式就完成了，随后就会释放 TCP 连接。

如果每次请求都要经历这样的过程，一次资源请求就断开链接，就是Http短链接
![[http_short_cnnect.png]]

这样实在太累人了，一次连接只能请求一次资源。

能不能在第一个 HTTP 请求完成后，先不断开 TCP 连接，让后续的 HTTP 请求继续使用此连接？

当然可以，HTTP 的 Keep-Alive 就是实现了这个功能，可以使用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，避免了连接建立和释放的开销，这个方法称为 **HTTP 长连接**。

![[http_long_connect.png]]


---


## HTTP1.1 如何对请求做拆包？

在 HTTP/1.1 中，请求的拆包是通过 `Content-Length` 头字段来进行的。该字段指示了请求正文的长度，服务器可以根据该长度来正确接收和解析请求。

具体来说，当客户端发送一个 HTTP 请求时，会在请求头中添加 `Content-Length` 字段，该字段的值表示请求正文的字节数。

服务器在接收到请求后，会根据 `Content-Length` 字段的值来确定请求的长度，并从请求中读取相应数量的字节，直到读取完整个请求内容。

这种基于 `Content-Length` 字段的拆包机制可以确保服务器正确接收到完整的请求，避免了请求的丢失或截断问题。

![[http_depackage.png]]


---


## HTTP 和 HTTPS 的区别
区别主要有以下四点：
- **安全性**：HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
- **连接过程**：HTTP 连接建立相对简单，TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
- **端口号**：两者的默认端口号不同，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
- **证书认证**：HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。


---


## HTTPS握手过程
传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的，在将 TLS 证书部署服务器时，证书文件其实就是服务器的公钥，会在 TLS 握手阶段传递给客户端，而服务器的私钥则一直留在服务器，一定要确保私钥不能被窃取。

在 RSA 密钥协商算法中，客户端会生成随机密钥，并使用服务器端的公钥加密后再传给服务器。根据非对称加密算法，公钥加密的消息仅能通过私钥解密，这样服务器端解密后，双方就得到了相同的密钥，再用它加密应用消息。

![[TSL.webp]]

### TLS 第一次握手
首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。在这一步，客户端主要向服务器发送以下信息：
1. 客户端支持的 TLS 协议版本，如 TLS 1.2 版本。
2. 客户端生成的随机数（Client Random），后面用于生成“会话秘钥”条件之一。
3. 客户端支持的密码套件列表，如 RSA 加密算法。

### TLS 第二次握手
服务器收到客户端请求后，向客户端发出响应，也就是 ServerHello。服务器回复的内容有如下内容：
1. 确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。
2. 服务器生成的随机数（Server Random），也是后面用于生成“会话秘钥”条件之一。
3. 确认的密码套件列表，如 RSA 加密法。
4. 服务器的数字证书。

### TLS 第三次握手
客户端收到服务器的响应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。
如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：
1. 一个随机数（pre-master key），该随机数会被服务器公钥加密。
2. 加密通信密钥交换过程，双方根据三个随机数（Client Random、Server Random、pre-master key）计算会话秘钥。
3. 客户端握手结束通知，表示客户端的握手阶段已经结束。

<span style="color: blue;">上述三个随机数最终会生成相同的“会话秘钥”，用于后续的加密通信。</span>

### TLS 第四次握手
服务器收到客户端的 pre-master key 之后，通过商定的加密算法，计算出本次通信的“会话秘钥”。
然后，向客户端发送以下信息：
1. 加密通信建立通知，表示后续的信息都将使用“会话秘钥”加密通信。
2. 服务器握手结束通知，表示握手阶段结束。

至此，TLS 的握手完成，接下来，客户端与服务器将用加密通信，继续使用普通的 HTTP 协议，只不过基于会话秘钥加密内容。


---


## HTTP/1.1 和 HTTP/2.0 的区别

HTTP/2 相比 HTTP/1.1 性能上的改进：
- **头部压缩**：HTTP/2 会压缩头（Header），如果你同时发出多个请求，它们的头是一样的或是相似的，那么协议会帮你 **消除重复的部分**。这就是所谓的 HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送相同字段了，只发送索引号，这样就提高了传输效率。
- **二进制格式**：HTTP/2 不再像 HTTP/1.1 里的纯文本格式的报文，而是全面采用了 **二进制格式**，头信息和数据帧都是二进制，用专门称为“帧”的单位传输：**头信息帧（Headers Frame）和数据帧（Data Frame）**。这样虽然对人不友好，但对计算机非常友好，能提高数据传输效率。
- **并发传输**：引入了 Stream 机制，多个 Stream 复用在一条 TCP 连接上，解决了 HTTP/1.1 队头阻塞的问题。
- **服务器主动推送资源**：HTTP/2 还在一定程度上改进了传统的“请求-应答”工作模式，服务器不再是被动地响应，可以主动向客户端发送消息。

### HPACK算法
1. **索引表维护**：
    - HPACK 在客户端和服务器端各自维护一个 **静态索引表** 和 **动态索引表**，其中存储的是头部字段的键值对。
    - **静态索引表** 预定义了一些常见的 HTTP 头部字段，比如 `:method GET`、`:status 200` 等。
    - **动态索引表** 会存储在通信过程中新添加的字段，后续如果相同字段再次出现，就不需要发送完整的键值对，而是只发送索引号。
2. **头部字段的索引编码**：
    - 如果头字段已经在索引表中，则只需发送索引编号，避免重复发送完整头部信息。
    - 如果头字段不在索引表中，则可以：
        - 直接发送完整键值对（不会存入索引表）。
        - 存入动态索引表，并发送索引编号，以供后续复用。
3. **增量更新**：
    - 客户端和服务器可以基于 HPACK 进行动态调整，始终保持高效的头部压缩。
    - 通过 **基于索引的方式复用头部字段**，HPACK 能有效减少冗余，提高 HTTP/2 的传输效率。

因此，HPACK **是对每个头部字段维护索引，而不是对整个头部建立一个索引**，这样可以更灵活地减少重复数据，提高压缩率和传输效率。


---


## HTTP、SOCKET 和 TCP 的区别

HTTP 是应用层协议，定义了客户端和服务器之间交换数据的格式和规则；Socket 是通信的接口，提供了网络通信的通道；TCP 是传输层协议，负责在网络中建立可靠的数据传输连接。它们在网络通信中扮演不同的角色和层次。
- **HTTP** 是一种用于传输超文本数据的应用层协议，用于在客户端和服务器之间传输和显示 Web 页面。
- **Socket** 是计算机网络中的一种抽象，用于描述通信链路的一端，提供了底层的通信接口，可实现不同计算机之间的数据交换。
- **TCP** 是一种面向连接、可靠的传输层协议，负责在通信的两端之间建立可靠的数据传输连接。


### 什么是 Socket？

Socket（套接字）是计算机网络中的一个 **通信端点**，用于在不同计算机之间建立数据传输连接。它本质上是操作系统提供的 **API 接口**，允许应用程序在网络上传输数据。


---

## DNS基础概念
DNS 的全称是 **Domain Name System（域名系统）**，它是互联网用于 **将域名转换为对应 IP 地址** 的分布式数据库系统。DNS 负责解析域名，使得人们可以通过易记的 **域名** 访问互联网资源，而不需要记住复杂的 **IP 地址**。

### **DNS 的域名结构**
DNS 中的域名使用 **句点（.）** 来分隔，例如 `www.server.com`，这里的句点代表不同层次之间的 **界限**。
在域名中，**越靠右的位置表示层级越高**。
例如：
- `com` 是顶级域（TLD，Top-Level Domain）。
- `server.com` 是二级域名。
- `www.server.com` 是完整的子域名。

![[DNS_basic.webp]]

### **域名解析顺序**
域名解析的结构类似于 **树状层级**，层次关系如下：
1. **根 DNS 服务器（.）**
2. **顶级域 DNS 服务器（.com）**
3. **权威 DNS 服务器（server.com）**

例如，在解析 `www.server.com` 时，查询流程如下：
1. 先查询 **根 DNS 服务器**，找到 `.com` 顶级域名服务器。
2. 由 **顶级域 DNS 服务器** 查找 `server.com` 的权威 DNS 服务器。
3. **权威 DNS 服务器** 提供 `www.server.com` 对应的 IP 地址。


### **根域名的作用**
实际上，域名在最后还有一个 **根域名**（`.`），例如 `www.server.com.`，这个 **最后的** `**.**` **代表根域名**，通常可以省略不写。
也就是说，**根域（**`**.**`**）是在最顶层**，其下层是 **.com 顶级域**，再往下是 **server.com 的权威 DNS 服务器**。
通过 DNS 解析，浏览器可以从 **域名** 转换为 **IP 地址**，最终访问目标服务器。


---


## DNS域名解析工作流程
1. 客户端首先会发出一个 DNS 请求，询问 `www.server.com` 的 IP 是啥，并发送给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。
2. 本地 DNS 服务器收到客户端的请求后，如果缓存表中能找到 `www.server.com`，则直接返回 IP 地址；如果没有，本地 DNS 会去问它的根域名服务器：“老大，能告诉我 `www.server.com` 的 IP 地址吗？” 根域名服务器是层级最高的，它不会直接解析域名，但会指明一条通路。
3. 根 DNS 收到来自本地 DNS 的请求后，发现后缀是 `.com`，说：“`www.server.com` 这个域名归 `.com` 区域管理”，并给出 `.com` 顶级域名服务器地址。
4. 本地 DNS 服务器收到顶级域名服务器的地址后，再去问它：“老二，你能告诉我 `www.server.com` 的 IP 地址吗？”
5. 顶级域名服务器返回：“我给你 `www.server.com` 区域的权威 DNS 服务器的地址，你去问它应该能问到。”
6. 本地 DNS 再转向权威 DNS 服务器：“老三，`www.server.com` 对应的 IP 是啥？” `server.com` 的权威 DNS 服务器负责解析 `server.com` 及其子域名，返回正确 IP 地址。
7. 权威 DNS 服务器查询后返回 `www.server.com` 的 IP 地址（如 `X.X.X.X`），告诉本地 DNS。
8. 本地 DNS 将 IP 地址返回给客户端，客户端根据此 IP 地址向目标服务器建立连接。

![[dns_workflow.webp]]


---

### **DNS 的底层使用 TCP 还是 UDP？**

DNS 基于 **UDP 协议** 实现，DNS 使用 UDP 协议进行域名解析和数据传输。因为基于 UDP 实现的 DNS 能够提供 **低延迟、简单快速、轻量级** 的特性，更适合 DNS 这种需要快速响应的域名解析服务。

#### **为什么 DNS 采用 UDP？**

- **低延迟**：UDP 是无连接协议，不需要在数据传输前建立连接，因此可以减少传输时延，适合 DNS 这种需要快速响应的应用场景。
- **简单快速**：UDP 相比 TCP 结构简单，没有连接管理和流量控制机制，传输效率更高，适合 DNS 这种需要高速传输数据的场景。
- **轻量级**：UDP 头部较小，占用较少的网络资源，对于小型请求和响应来说更为轻量级，适合 DNS 这种频繁短小的数据交换。

尽管 UDP 存在 **丢包和数据损坏** 的风险，但在 DNS 的设计中，这些风险是可以被容忍的。DNS 使用了一些机制来提高可靠性，例如 **查询超时、请求重试、缓存等**，以确保数据传输的可靠性和正确性。



---
## Cookie 和 Session 的区别

Cookie 和 Session 都是 Web 开发中用于跟踪用户状态的技术，但它们在存储位置、数据容量、安全性以及生命周期等方面存在显著差异：

## **1. 存储位置**

- **Cookie** 的数据存储在客户端（通常是浏览器）。当浏览器向服务器发送请求时，会自动附带 Cookie 中的数据信息。
- **Session** 的数据存储在服务器端，服务器会给每个用户分配一个唯一的 Session ID，这个 ID 通常通过 Cookie 或 URL 重新传递给客户端，客户端后续的请求会带上这个 Session ID，服务器根据 ID 查找对应的 Session 数据。

## **2. 数据存储容量**

- **Cookie**：单个 Cookie 的大小限制通常在 **4KB 左右**，而且大多数浏览器对每个域名的总 Cookie 数量也有限制。
- **Session**：存储在服务器端，**理论上不受数据大小的限制**，主要取决于服务器的内存大小。

## **3. 安全性**

- **Cookie** 相对不安全，因为数据存储在客户端，容易受到 **XSS（跨站脚本攻击）** 的影响。不过可以通过 `HttpOnly` 属性防止 JavaScript 访问 Cookie，减少 XSS 攻击的风险，但仍然可能受到 **CSRF（跨站请求伪造）** 攻击。
- **Session** 通常比 Cookie 更安全，因为敏感数据存储在 **服务器端**，但仍然需要防范 **Session 劫持（如截获他人的 Session ID）** 和 **会话固定攻击**。

## **4. 生命周期**

- **Cookie**：可以设置 **过期时间**，到期后会自动删除，也可以设置为 **会话 Cookie**，即浏览器关闭时自动删除。
- **Session**：默认情况下，当用户关闭浏览器时，Session 失效。但服务器也可以手动设置 Session 过期时间，这样这个时间内，即使关闭浏览器，Session 也会继续有效。

## **5. 性能**

- **使用 Cookie**：因为数据需要随每次请求发送到服务器，可能会 **增加网络传输的开销**，特别是在 Cookie 数据较大的时候。
- **使用 Session**：因为数据存储在 **服务器端**，每次请求时都需要查询服务器上的 Session 数据，可能会 **增加服务器的负载**，特别是在高并发场景下。

## **总结对比**

| **对比项**   | **Cookie**             | **Session**             |
| --------- | ---------------------- | ----------------------- |
| **存储位置**  | 客户端（浏览器）               | 服务器                     |
| **数据存储**  | 4KB 限制，浏览器限制 Cookie 数量 | 理论上无大小限制，受服务器内存限制       |
| **安全性**   | 容易被篡改、XSS 攻击、CSRF 攻击   | 相对安全，但可能遭受 Session 劫持   |
| **生命周期**  | 可设置过期时间，默认随浏览器关闭而删除    | 默认随浏览器关闭，服务器可设定超时       |
| **适用场景**  | 存储简单的用户信息（如用户 ID、主题偏好） | 存储敏感数据（如用户认证、购物车）       |
| **服务器压力** | 无服务器负担，数据存储在客户端        | 服务器需要存储 Session 数据，压力较大 |


---


## **Token、Session 和 Cookie 的区别**

- **Session** 存储在服务器端，可以理解为一个状态列表，拥有一个唯一识别符 `sessionId`，通常存放于 Cookie 中。服务器收到 Cookie 后解析出 `sessionId`，再去 Session 列表中查找，才能找到相应的 Session，依赖 Cookie。
- **Cookie** 类似一个令牌，装着 `sessionId`，存储在客户端，浏览器通常会自动添加。
- **Token** 也类似一个令牌，无状态，用户信息被加密到 Token 中，服务器收到 Token 后解密即可知道用户，无需存储状态。


---


## **如果客户端禁用了 Cookie，Session 还能用吗？**

**默认情况下禁用 Cookie 后，Session 是无法正常使用的**，因为大多数 Web 服务器都是依赖于 Cookie 来传递 Session ID 的。

如果 **客户端浏览器禁用 Cookie**，服务器将无法把会话 ID 发送给客户端，客户端也无法在后续请求中携带会话 ID 返回给服务器，从而导致服务器无法识别用户会话。

### **绕过 Cookie 限制的解决方案**

虽然 Cookie 被禁用会导致 Session 失效，但可以通过以下方法绕过这一问题（但会带来额外的复杂性或安全性风险）：

1. **URL 传参**
    - 服务器响应时，在 URL 中 **附加 Session ID** 作为参数，例如：
        ```css
        http://example.com/page?sessionid=XXXXXX
        ```
    - 服务器需要解析 URL 以获取 Session ID，并维持用户的会话状态。
    - **缺点**：
        - URL 可能被第三方截获或共享，导致 Session ID **意外泄露**。
        - 不适合敏感操作，如在线支付。

2. **隐藏表单字段**
    - 每个需要 Session 信息的 HTML 表单中都包含一个 **隐藏字段**，存储 `Session ID`。
    - 当表单提交时，Session ID 被包含在请求数据中，服务器解析表单数据中的 `Session ID` 来获取用户会话信息。
    - **缺点**：
        - 仅适用于 **表单提交请求**，不适合直接点击链接或 Ajax 请求。
        - 可能会影响前端用户体验。

### **总结**
- **大多数情况下，Session 依赖于 Cookie，如果 Cookie 被禁用，Session 也无法使用。**
- **可以通过 URL 传参或隐藏表单字段传递 Session ID，但这些方法存在安全性和可用性的问题。**
- **最好的解决方案是使用 Token（如 JWT）代替 Session，使其不依赖 Cookie 存储会话信息。**


---

## **LocalStorage 和 Cookie 的区别**

1. **存储容量**：
    - **Cookie** 的存储容量较小，单个 Cookie 大小通常限制在 **4KB** 左右。
    - **LocalStorage** 的存储容量较大，一般 **限制在 5MB 左右**，适用于存储大量数据。
2. **数据发送**：
    - **Cookie** 在每次 HTTP 请求中都会自动携带并发送到服务器，适用于客户端和服务器之间的数据传输。
    - **LocalStorage** 的数据不会自动发送到服务器，它仅在浏览器端存储数据，适用于 **前端页面之间共享数据**。
3. **生命周期**：
    - **Cookie** 可以设置过期时间，到期后自动删除。
    - **LocalStorage** 的数据默认 **永久有效**，除非手动删除。
4. **安全性**：
    - **Cookie** 可能被 **XSS 攻击** 窃取，且每次 HTTP 请求都会携带，可能被中间人拦截。
    - **LocalStorage** 仅存储在本地，不会自动发送到服务器，相对安全。

### **什么数据适合存储在 Cookie，什么数据适合存储在 LocalStorage？**
- **Cookie** 适用于 **客户端和服务器之间的通信**，用于 **跨域访问** 或 **短期存储会话信息**。
- **LocalStorage** 适用于 **前端页面间的数据共享**，适合存储 **大量数据** 和 **长久存储的数据**。


---


## **JWT 令牌和传统方式有什么区别？**
1. **无状态性**：JWT 是无状态的令牌，不需要在服务器端存储会话信息。JWT 令牌中包含所有必要的信息，如用户身份、权限等，使得 JWT 在分布式系统中更适用，能够方便地进行扩展和跨域访问验证。
2. **安全性**：JWT 采用加密技术对令牌进行签名，确保令牌的完整性和真实性。只有持有正确密钥的服务器才能对令牌进行验证和解析。这种方式比基于会话和 Cookie 的验证更安全，有效防止 CSRF（跨站请求伪造）等攻击。
3. **跨域支持**：JWT 令牌可以不依赖 Cookie 进行传输，适用于跨域访问的场景。通常通过请求的头部或 URL 参数中携带 JWT 令牌，实现无 Cookie 的跨域身份验证。


---

## JWT令牌的结构
JWT 令牌由三部分组成：
- **头部（Header）**
- **载荷（Payload）**
- **签名（Signature）**

这三部分均为 JSON 格式，并使用 Base64 进行编码，且在传输时需要完整发送这三个部分。通常 JWT 令牌会被放在 HTTP 请求头的 `Authorization` 字段。
![[JWT_structure.webp]]

### **为什么要传输完整的 Header、Payload、Signature？**
- **完整性验证**：服务器需要 `Header` 和 `Payload` 来解析 JWT 令牌的内容，同时需要 `Signature` 验证数据的完整性和真实性。
- **防篡改**：如果只传输 `Signature`，服务器无法验证 `Header` 和 `Payload` 是否被修改。

### **JWT 签名（Signature）无法被解码**

JWT 的 **第三部分（Signature，签名）** 是 **密钥签名的哈希值**，无法被反向解析。
- 服务器在验证 JWT 时，会 **重新计算签名并与 JWT 提供的签名对比**，如果一致，则说明 JWT 是合法的，未被篡改。
- **没有密钥，攻击者无法篡改 JWT**，因为修改 `Header` 或 `Payload` 后，签名将不再匹配。


### **JWT 解析 vs 验证**

|操作|是否需要密钥|作用|
|---|---|---|
|**解码（decode）**|❌ 不需要|任何人都可以解析 Header 和 Payload（明文信息）|
|**验证（verify）**|✅ 需要|服务器使用密钥验证 JWT 是否被篡改|


---


##  **JWT 令牌为什么能解决集群部署？什么是集群部署？**

在传统的基于会话和 Cookie 的身份验证方式中，会话信息通常存储在服务器的内存或数据库中。但是在 **集群部署** 中，不同的服务器之间没有共享的会话信息，这会导致：
- 用户在不同服务器之间切换时，需要 **重新登录**。
- 需要引入 **共享存储机制（如 Redis 集群）**，增加了系统的复杂性和性能开销。

### **JWT 令牌的优势**

JWT 令牌通过 **自包含（self-contained）** 方式解决了这一问题。
1. **JWT 令牌中包含所有身份认证和会话信息**，服务器无需存储会话数据。
2. **用户登录时，服务器生成 JWT 并返回给客户端**，后续请求中，客户端直接携带该令牌。
3. **服务器只需验证 JWT 的签名** 即可确认用户身份，而不需要访问数据库或共享存储。
4. **集群中的每个服务器都可以独立处理请求**，提高了系统的可扩展性和容错性。


### **对比传统方式（基于 Session + Redis 共享存储）**

|方式|传统 Session 方式|JWT 方式|
|---|---|---|
|**会话存储**|服务器端（或 Redis）|客户端（令牌中）|
|**服务器负担**|需要共享存储，影响性能|服务器无状态，减少存储压力|
|**扩展性**|需要 Redis 共享存储|服务器可独立扩展，无需共享存储|
|**安全性**|需要保护 Session ID|JWT 需要妥善管理密钥防止泄露|


---

## **JWT 的缺点是什么？**

1. **无法即时撤销**：JWT 一旦签发出去，在失效之前都是有效的，无法立即使其失效。
2. **黑名单机制**：为了解决 JWT 失效控制问题，可以使用 **黑名单机制**，即在 Redis 等存储中维护一个黑名单列表，如果检测到某个 JWT 需要失效，就将其加入黑名单。
3. **占用带宽**：JWT 令牌通常比 Session ID 体积更大，因为包含了用户信息、签名等内容，可能会增加带宽消耗。

## **JWT 令牌如果泄露了，怎么解决？**

1. **即时失效令牌**：服务器可以检测到 JWT 令牌泄露时，立即将该令牌标记为失效，并拒绝使用该令牌的任何请求。
2. **刷新令牌机制（Refresh Token）**：JWT 令牌通常具有短有效期，用户可定期刷新获取新令牌。当检测到令牌泄露时，可以通过刷新机制生成新令牌并废弃旧令牌，减少被滥用的风险。
3. **黑名单机制**：服务器可以维护一个黑名单存储已泄露的 JWT，在收到请求时先检查 JWT 是否在黑名单中，确保它不能继续使用。


---

## **前端存储 JWT 令牌的方式**

JWT 令牌可以存储在 **Local Storage、Session Storage 或 Cookie** 中，各有优缺点：

### **Local Storage（本地存储）**
- **优点**：
    - 提供 **较大的存储空间**（一般为 **5MB** ）。
    - **不会随 HTTP 请求自动发送**，避免了不必要的流量开销。
- **缺点**：
    - **容易受到 XSS（跨站脚本攻击）** 影响，恶意脚本可以通过 JavaScript 访问 Local Storage 获取 JWT 并盗用用户身份。
### **Session Storage（会话存储）**
- **优点**：
    - 类似于 Local Storage，但 **仅在当前会话窗口或标签页** 内有效，**关闭窗口后自动清除数据**。
    - **降低了数据泄露的风险**，因为 JWT 仅在当前页面会话内有效。
- **缺点**：
    - **用户体验影响较大**，因为 **刷新页面或打开新标签页** 可能会导致重新登录。

### **Cookie**
- **优点**：
    - 可以设置 `HttpOnly` **防止 JavaScript 访问 JWT**，减少 XSS 攻击风险。
    - 可以结合 `Secure` 标志 **确保 JWT 仅通过 HTTPS 发送**，提高安全性。
- **缺点**：
    - **存储容量较小**（一般 **4KB** ）。
    - 每次 HTTP 请求都会自动携带 JWT，可能影响性能。
    - 可能受到 **CSRF（跨站请求伪造）** 攻击，需要额外的防范措施（如使用 `SameSite` 标志）。


---


## Session_id存在cookie还是session storage
### **Session ID 存储在 Cookie，而不是 Session Storage**

- **Session ID** 是服务器用来标识用户会话的唯一标识符，通常存储在 **浏览器的 Cookie 中**。
- **Session Storage** 是浏览器的本地存储，它是 **前端用于临时存储数据** 的地方，不会自动携带到服务器。

**为什么不把 Session ID 存在 Session Storage？**
- **Session Storage 不能自动随请求发送**，但 Session ID 需要随请求携带到服务器，以便服务器识别用户会话。
- **Session Storage 仅在当前标签页生效**，如果用户打开新标签页，Session Storage 的数据不会被共享，而 Session ID 需要在所有请求中有效。
- **Session Storage 主要用于前端数据缓存**，如临时存储用户输入的信息，而 Session ID 的目的是用于身份验证，通常由后端管理。

### **2. 为什么 Session（服务器端）会随着浏览器关闭而失效？**

在大多数实现中，服务器端 Session 之所以会 **“随浏览器关闭失效”**，是因为 **Session ID 默认存储在会话 Cookie（Session Cookie）中**：

- **会话 Cookie（Session Cookie）**：
    - **默认行为**：当浏览器关闭时，**会话 Cookie 被删除**，因此服务器端不会再接收到 Session ID，从而导致会话失效。
    - **影响**：当用户重新打开浏览器时，**不会携带 Session ID，服务器认为是新会话**。
- **持久化 Cookie（Persistent Cookie）**：
    - 如果手动设置 `Expires` 或 `Max-Age`，则 **Session ID 仍然保留**，即使关闭浏览器，用户下次打开仍然可以继续访问会话。

**服务器端的 Session 并不会因为浏览器关闭而自动删除**，但如果用户的 Session ID 不再可用（如会话 Cookie 被删除），服务器就无法识别用户会话。


---


## **微服务是什么？**

微服务（Microservices）是一种 **系统架构模式**，它将一个**大而复杂的应用程序拆分成多个独立的小服务**，这些小服务各自负责不同的功能，并可以独立开发、部署和运行。

- 传统的 **单体架构**：所有功能都写在同一个应用中，如 **电商网站** 包含 **用户管理、订单管理、支付系统、库存管理** 等，所有代码都在一个项目里。
    
- **微服务架构**：把这些功能拆分成 **独立的服务**，比如 **用户服务、订单服务、支付服务、库存服务**，它们可以单独运行，相互通过 **网络通信** 进行交互。
    

✅ **好处**：
1. **独立部署**：修改订单服务不会影响用户服务。
2. **技术栈灵活**：每个服务可以用不同的编程语言、数据库等。
3. **高可扩展性**：可以单独扩展某个高流量的服务（如订单）。
4. **故障隔离**：一个服务崩溃不会影响整个系统。

## **RPC（Remote Procedure Call，远程过程调用） 在微服务中的应用**

微服务架构中，每个服务都是**独立的程序**，但它们之间需要 **互相调用**，比如：
- **订单服务** 需要调用 **用户服务** 来获取用户信息。
- **支付服务** 需要调用 **订单服务** 来获取订单详情。

✅ **RPC 让微服务之间的调用像本地函数一样简单，提高了通信效率**。 ✅ **HTTP 更适合外部 API（如前端请求），但微服务间的高效通信一般使用 RPC**。


---

## 什么有 HTTP 协议了？还要用 RPC？

- **RPC 本质上不算是协议，而是一种调用方式**，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的具体协议。目的是希望程序员像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，不一定得基于 TCP 协议。
    
- **从发展历史来看**，HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。现在其实已经没那么清晰了，B/S 和 C/S 在慢慢融合。很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。
    
- **RPC 其实比 HTTP 也快的要早**，且也是当前主流的 HTTP/1.1 性能要更好，所以大部分公司内部仍在使用 RPC。
    
- **HTTP/2 在 HTTP/1.1 的基础上做了很多优化**，性能可能比很多 RPC 协议还要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。


---

## HTTP长连接与WebSocket有什么区别？

- **全双工和半双工**：TCP 协议本身是**全双工**的，但我们最常用的 HTTP/1.1，虽然是基于 TCP 的协议，但它是**半双工**的。对于大部分需要服务器主动推送数据到客户端的场景，都不太友好，因此我们需要使用支持全双工的 WebSocket 协议。
    
- **应用场景区别**：在 HTTP/1.1 里，只要客户端不问，服务器就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用**定时轮询或者长轮询**的方式实现**服务器推送**（comet）的效果。对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用 WebSocket 协议。

### 定时轮询（Polling）
**原理**：客户端以固定时间间隔（如 5 秒）向服务器发送请求，服务器返回最新的数据。

### 长轮询（Long Polling）
**原理**：客户端发送请求后，服务器不会立即返回数据，而是等待新的数据可用时再返回，客户端接收到响应后立即发送新的请求。


### **对比**

| 方式       | 实现难度 | 服务器压力 | 延迟  | 适用场景                       |
| -------- | ---- | ----- | --- | -------------------------- |
| **定时轮询** | 简单   | 高     | 高   | 低频更新，如定期刷新页面数据             |
| **长轮询**  | 中等   | 低     | 低   | 适用于需要更实时但不想用 WebSocket 的场景 |

如果你的应用需要 **真正的实时通信（如在线聊天、游戏）**，推荐使用 **WebSocket** 代替轮询。


---


## Nginx有哪些负载均衡算法？

Nginx 支持的负载均衡算法包括：
- **轮询**：按照顺序依次将请求分配给后端服务器。这种算法最简单，但是也无法处理某个节点变慢或者客户端操作有连续性的情况。
- **IP 绑定（IP 哈希）**：根据客户端 IP 地址的哈希值来确定分配请求的后端服务器。适用于需要保持同一客户端的请求始终发送到同一台后端服务器的场景，如会话保持。
- **URL 哈希**：按请求的 URL 结构哈希结果来分配请求，使得一个 URL 定向到一台后端服务器，可以进一步提高后端缓存服务器的效率。
- **最短响应时间**：按照后端服务器的响应时间，响应时间短的优先分配。适用于后端服务器性能不均的场景，能够将请求发送到响应时间快的服务器，实现负载均衡。
- **加权轮询**：按照服务器性能分配权重，性能好的服务器获得更多的请求。适用于后端服务器性能不均的场景，可以根据服务器权重分配请求，提高服务器的利用率。


---


## Nginx位于七层网络结构中的哪一层？
**应用层**，Nginx 是七层负载均衡。
