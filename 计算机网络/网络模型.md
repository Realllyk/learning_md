![[tcp_ip.png]]
## TCP/IP
- **应用层** 支持 HTTP、SMTP 等最终用户进程
- **传输层** 处理主机到主机的通信（TCP、UDP）
- **网络层** 寻址和路由数据包（IP 协议）
- **链路层** 通过网络的物理电缆、电缆或无线信道移动比特
### tcp、ip 分别位于哪一层？
- **tcp** 在传输层
- **ip** 在网络层


---


## Http报文
![[http_segment.png]]
### 请求报文
- **请求行**：包含请求方法、请求目标（URL 或 URI）和 HTTP 协议版本。
- **请求头部**：包含关于请求的附加信息，如 Host、User-Agent、Content-Type 等。
- **空行**：请求头部和请求体之间用空行分隔。
- **请求体**：可选，包含请求的数据，通常用于 POST 请求等需要传输数据的情况。

### 响应报文
- **状态行**：包含 HTTP 协议版本、状态码和状态信息。
- **响应头部**：包含关于响应的附加信息，如 Content-Type、Content-Length 等。
- **空行**：响应头部和响应体之间用空行分隔。
- **响应体**：包含响应的数据，通常是服务器返回的 HTML、JSON 等内容。



---


## Http状态码
HTTP 状态码分为 5 大类：
- **1xx** 类状态码属于 **提示信息**，是协议处理中的一种中间状态，实际用到的比较少。
- **2xx** 类状态码表示服务器 **成功** 处理了客户端的请求，也是我们最愿意看到的状态。
- **3xx** 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是 **重定向**。
- **4xx** 类状态码表示客户端发送 **报文有误**，服务器无法处理，也就是错误的含义。
- **5xx** 类状态码表示客户端报文正确，但是 **服务器处理时内部发生了错误**，属于服务器端的错误码。

### 常见的具体状态码：
- **200**：请求成功。
- **301**：永久重定向； **302**：临时重定向。
- **404**：无法找到对应页面。
- **405**：请求的方法类型不支持。
- **500**：服务器内部错误。

### HTTP 返回状态 301 和 302 的区别

3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是 **重定向**。
- **301 Moved Permanently**：表示永久重定向，说明请求的资源已经不存在了，需要改用新的 URL 重新访问。
- **302 Found**：表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。
301 和 302 都会在响应头里使用字段 `Location`，指明后续要跳转的 URL，浏览器会自动重定向到新的 URL。

### HTTP 502 和 504 的区别
- **502 Bad Gateway**：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。
- **504 Gateway Time-out**：作为网关或代理工作的服务器尝试执行请求时，未能及时从上游服务器收到响应。

举一个例子，假设 nginx 是代理服务器，收到客户端的请求后，将请求转发到后端服务器（如 Tomcat）。
- 当 nginx 收到了无效的响应时，就返回 **502**。
- 当 nginx 超过自己配置的超时时间，还没有收到请求时，就返回 **504** 错误


## Http长连接
HTTP 协议采用的是「请求-应答」的模式，也就是客户端发起了请求，服务端才会返回响应，一来一回这样的交互方式。

由于 HTTP 是基于 TCP 传输协议实现的，客户端与服务端要进行 HTTP 通信前，需要先建立 TCP 连接，然后客户端发送 HTTP 请求，服务端收到后就返回响应，至此「请求-应答」的模式就完成了，随后就会释放 TCP 连接。

如果每次请求都要经历这样的过程，一次资源请求就断开链接，就是Http短链接
![[http_short_cnnect.png]]

这样实在太累人了，一次连接只能请求一次资源。

能不能在第一个 HTTP 请求完成后，先不断开 TCP 连接，让后续的 HTTP 请求继续使用此连接？

当然可以，HTTP 的 Keep-Alive 就是实现了这个功能，可以使用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，避免了连接建立和释放的开销，这个方法称为 **HTTP 长连接**。

![[http_long_connect.png]]


---


## ## HTTP1.1 如何对请求做拆包？

在 HTTP/1.1 中，请求的拆包是通过 `Content-Length` 头字段来进行的。该字段指示了请求正文的长度，服务器可以根据该长度来正确接收和解析请求。

具体来说，当客户端发送一个 HTTP 请求时，会在请求头中添加 `Content-Length` 字段，该字段的值表示请求正文的字节数。

服务器在接收到请求后，会根据 `Content-Length` 字段的值来确定请求的长度，并从请求中读取相应数量的字节，直到读取完整个请求内容。

这种基于 `Content-Length` 字段的拆包机制可以确保服务器正确接收到完整的请求，避免了请求的丢失或截断问题。

![[http_depackage.png]]


---


## HTTP 和 HTTPS 的区别
区别主要有以下四点：
- **安全性**：HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
- **连接过程**：HTTP 连接建立相对简单，TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
- **端口号**：两者的默认端口号不同，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
- **证书认证**：HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。


---


## HTTPS握手过程
传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的，在将 TLS 证书部署服务器时，证书文件其实就是服务器的公钥，会在 TLS 握手阶段传递给客户端，而服务器的私钥则一直留在服务器，一定要确保私钥不能被窃取。

在 RSA 密钥协商算法中，客户端会生成随机密钥，并使用服务器端的公钥加密后再传给服务器。根据非对称加密算法，公钥加密的消息仅能通过私钥解密，这样服务器端解密后，双方就得到了相同的密钥，再用它加密应用消息。

![[TSL.webp]]

### TLS 第一次握手
首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。在这一步，客户端主要向服务器发送以下信息：
1. 客户端支持的 TLS 协议版本，如 TLS 1.2 版本。
2. 客户端生成的随机数（Client Random），后面用于生成“会话秘钥”条件之一。
3. 客户端支持的密码套件列表，如 RSA 加密算法。

### TLS 第二次握手
服务器收到客户端请求后，向客户端发出响应，也就是 ServerHello。服务器回复的内容有如下内容：
1. 确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。
2. 服务器生成的随机数（Server Random），也是后面用于生成“会话秘钥”条件之一。
3. 确认的密码套件列表，如 RSA 加密法。
4. 服务器的数字证书。

### TLS 第三次握手
客户端收到服务器的响应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。
如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：
1. 一个随机数（pre-master key），该随机数会被服务器公钥加密。
2. 加密通信密钥交换过程，双方根据三个随机数（Client Random、Server Random、pre-master key）计算会话秘钥。
3. 客户端握手结束通知，表示客户端的握手阶段已经结束。

<span style="color: blue;">上述三个随机数最终会生成相同的“会话秘钥”，用于后续的加密通信。</span>

### TLS 第四次握手
服务器收到客户端的 pre-master key 之后，通过商定的加密算法，计算出本次通信的“会话秘钥”。
然后，向客户端发送以下信息：
1. 加密通信建立通知，表示后续的信息都将使用“会话秘钥”加密通信。
2. 服务器握手结束通知，表示握手阶段结束。

至此，TLS 的握手完成，接下来，客户端与服务器将用加密通信，继续使用普通的 HTTP 协议，只不过基于会话秘钥加密内容。


---


## HTTP/1.1 和 HTTP/2.0 的区别

HTTP/2 相比 HTTP/1.1 性能上的改进：
- **头部压缩**：HTTP/2 会压缩头（Header），如果你同时发出多个请求，它们的头是一样的或是相似的，那么协议会帮你 **消除重复的部分**。这就是所谓的 HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送相同字段了，只发送索引号，这样就提高了传输效率。
- **二进制格式**：HTTP/2 不再像 HTTP/1.1 里的纯文本格式的报文，而是全面采用了 **二进制格式**，头信息和数据帧都是二进制，用专门称为“帧”的单位传输：**头信息帧（Headers Frame）和数据帧（Data Frame）**。这样虽然对人不友好，但对计算机非常友好，能提高数据传输效率。
- **并发传输**：引入了 Stream 机制，多个 Stream 复用在一条 TCP 连接上，解决了 HTTP/1.1 队头阻塞的问题。
- **服务器主动推送资源**：HTTP/2 还在一定程度上改进了传统的“请求-应答”工作模式，服务器不再是被动地响应，可以主动向客户端发送消息。

### HPACK算法
1. **索引表维护**：
    - HPACK 在客户端和服务器端各自维护一个 **静态索引表** 和 **动态索引表**，其中存储的是头部字段的键值对。
    - **静态索引表** 预定义了一些常见的 HTTP 头部字段，比如 `:method GET`、`:status 200` 等。
    - **动态索引表** 会存储在通信过程中新添加的字段，后续如果相同字段再次出现，就不需要发送完整的键值对，而是只发送索引号。
2. **头部字段的索引编码**：
    - 如果头字段已经在索引表中，则只需发送索引编号，避免重复发送完整头部信息。
    - 如果头字段不在索引表中，则可以：
        - 直接发送完整键值对（不会存入索引表）。
        - 存入动态索引表，并发送索引编号，以供后续复用。
3. **增量更新**：
    - 客户端和服务器可以基于 HPACK 进行动态调整，始终保持高效的头部压缩。
    - 通过 **基于索引的方式复用头部字段**，HPACK 能有效减少冗余，提高 HTTP/2 的传输效率。

因此，HPACK **是对每个头部字段维护索引，而不是对整个头部建立一个索引**，这样可以更灵活地减少重复数据，提高压缩率和传输效率。


---


## HTTP、SOCKET 和 TCP 的区别

HTTP 是应用层协议，定义了客户端和服务器之间交换数据的格式和规则；Socket 是通信的接口，提供了网络通信的通道；TCP 是传输层协议，负责在网络中建立可靠的数据传输连接。它们在网络通信中扮演不同的角色和层次。
- **HTTP** 是一种用于传输超文本数据的应用层协议，用于在客户端和服务器之间传输和显示 Web 页面。
- **Socket** 是计算机网络中的一种抽象，用于描述通信链路的一端，提供了底层的通信接口，可实现不同计算机之间的数据交换。
- **TCP** 是一种面向连接、可靠的传输层协议，负责在通信的两端之间建立可靠的数据传输连接。


### 什么是 Socket？

Socket（套接字）是计算机网络中的一个 **通信端点**，用于在不同计算机之间建立数据传输连接。它本质上是操作系统提供的 **API 接口**，允许应用程序在网络上传输数据。

