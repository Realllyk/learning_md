## 描述打开百度首页后的网络过程

![[request_baidu.webp]]

### **1. 解析 URL**
解析 URL 需要确定传输协议和请求的资源路径。如果输入的 URL 的协议或主机名不合法，浏览器会进行错误处理。如果 URL 格式正确，浏览器会检查其中是否有非法字符，并进行必要的转换。
### **2. 进行缓存查询**
浏览器首先检查**本地缓存**（如 `hosts` 文件）、**路由器缓存**、**ISP 的 DNS 缓存**，如果缓存中有对应的 IP 地址，则直接访问服务器。

### **3. 进行 DNS 解析**
如果缓存中没有匹配的 IP 地址，浏览器会向本地 DNS 服务器发送请求，最终可能通过**根域名服务器**、**顶级域名服务器（TLD）** 逐级查询，直到找到目标域名对应的 IP 地址。

### **4. 获取目标 MAC 地址**
- 当浏览器得到服务器的 IP 地址后，系统需要获取目标服务器的 MAC 地址，以便进行数据传输。
- TCP 协议会在数据包中包含源端口号和目标端口号，然后交给网络层。
- 网络层将 **IP 地址作为目标地址**，继续查找下一跳的 MAC 地址。
- 通过 **ARP 协议** 获取目标 MAC 地址，如果服务器和客户端不在同一网段，数据包将先被转发到网关，由网关继续查找服务器的 MAC 地址。

### **5. 建立 TCP 连接**
- 主机向目标 IP 地址和 MAC 地址发送 **TCP SYN** 报文，请求建立连接。
- 数据包在网络中通过路由器转发，最终到达目标服务器。
- 服务器返回 **SYN-ACK**，确认连接请求。
- 客户端发送 **ACK**，确认收到服务器的确认，TCP 连接正式建立。

### **6. TLS 连接（如果是 HTTPS）**
如果使用 **HTTPS**，在 TCP 连接建立后，会进行 **TLS 的四次握手** 以建立安全加密通道。

### **7. 发送 HTTP 请求**
- 连接建立后，浏览器向服务器发送 HTTP 请求，通常包括：
    - **请求的 URL**
    - **请求方法（如 GET 或 POST）**
    - **请求头部信息（如 User-Agent, Accept-Encoding）**

### **8. 服务器处理请求并返回响应**
- 服务器解析请求，查找对应资源，例如网页内容。
- 服务器生成 HTTP 响应，并返回给客户端。

### **9. 渲染页面并显示内容**
- 浏览器解析 HTML 内容，加载 CSS、JavaScript 和图片等资源。
- 渲染页面并最终展示百度首页。


---


## **网页非常慢转圈圈时的排查方法**

### **1. 确定是服务器端问题还是客户端问题**
- 先检查浏览器是否可以访问其他网站。
    - 如果所有网站都无法访问，说明客户端的网络存在问题，需要检查网络配置（如 WiFi 连接是否正常、网线是否插好）。
    - 如果可以访问其他网站，则说明客户端的网络是正常的。

### **2. 检查 DNS 解析和 TCP 连接**
- 如果客户端网络没有问题，就需要抓包确认 **DNS 是否解析出了 IP 地址**。
    - 如果域名解析失败，可能是域名拼写错误或 DNS 服务器有问题
    - 如果 DNS 能解析出 IP 地址，则继续检查 **是否与服务器建立了 TCP 三次握手**。
- 如果 TCP 连接建立成功，并且 HTTP 请求已经发出，但网页仍然加载缓慢，可以检查服务器返回的响应码：
    - **404 错误**：说明访问的 URL 可能输入错误。
    - **500 错误**：说明服务器端有问题。
    - **200 状态码**：可以打开 F12 开发者工具，查看前端代码是否导致页面渲染问题。
### **3. 检查网络带宽和丢包情况**
- 如果客户端网络是正常的，但**加载速度仍然很慢**，可能是**网络带宽不足或 TCP 丢包**导致的数据传输缓慢。
- 需要使用网络监测工具查看客户端的流量占用情况。


---


如果服务器不主动发送数据给客户端，那么服务器端是永远无法感知到客户端是否断开的，也就是服务器端的 TCP 连接会一直处于 ESTABLISH 状态，占用着系统资源。

为了解决这种情况，TCP 提供了**保活机制**。其原理如下：
- 在规定的时间段内，如果没有任何连接相关的活动，TCP 保活机制就会开始。
- 每隔一段时间，发送一个**探测报文**，该报文一般为空。
- 如果多次探测报文没有得到回应，则认为当前 TCP 连接已经失效，系统会将错误信息通知给上层应用程序。

### **Linux 内核的 TCP 保活参数**

Linux 内核可以通过以下参数来设置保活时间、保活探测的次数、保活探测的时间间隔，默认值如下：

```
net.ipv4.tcp_keepalive_time=7200
net.ipv4.tcp_keepalive_intvl=75
net.ipv4.tcp_keepalive_probes=9
```

- **tcp_keepalive_time=7200**：表示**2 小时**（7200 秒）内如果没有任何连接相关的活动，则会启动 TCP 保活机制。
    
- **tcp_keepalive_intvl=75**：表示每次探测的时间间隔是 75 秒。
    
- **tcp_keepalive_probes=9**：表示最多探测 9 次无响应，则判定对方不可达，并中断连接。
    

换句话说，Linux 内核默认需要至少**2 小时 11 分 15 秒**才能发现一条“死亡”连接。

### **应用层使用 TCP 保活机制的条件**

如果应用程序希望使用 TCP 保活机制，需要在 socket 接口上**显式设置** `**SO_KEEPALIVE**` **选项**，否则系统不会自动启用保活机制。

---


## 如何判断TCP连接是否正常

### **TCP 保活异常情况分析**
如果 TCP 保活探测报文发送后没有得到回应，可能会遇到以下三种情况：
#### **1. 正常情况**
- **对端服务器正常运行**，收到 TCP 保活探测报文后正常回应。
- 连接仍然有效，等待下一个 TCP 保活探测。

#### **2. 对端服务器崩溃（进程未正常关闭）**
- 如果服务器崩溃或重启，TCP 保活探测报文仍然可以到达对端，但因没有连接的有效信息，
- **对端会返回一个** `RST` **报文**，此时 TCP 连接会立即被重置（Connection Reset）。

#### **3. 对端主机宕机（非正常退出）**
- **注意：这不同于进程崩溃，进程崩溃后操作系统回收进程资源时，会发送FIN报文**。宕机时，服务器不会主动发送 `FIN` 报文。
- 在宕机的情况下，**TCP 保活探测报文会石沉大海**，收不到任何响应。
- 直到探测次数达到 `tcp_keepalive_probes`，系统才会断开连接，并向应用层报告连接失效。


### **应用层如何优化连接检测？**

#### **1. Web 服务器超时机制（KeepAlive Timeout）**
Web 服务器一般会提供 `keepalive_timeout` 选项，
- 例如 HTTP 长连接超时时间设为 60 秒。
- 如果客户端在 60 秒内未发送任何请求，服务器会主动关闭连接，释放资源。

#### **2. 应用层心跳机制**
- TCP 保活机制检测间隔较长（默认 2 小时），
- 可以**在应用层实现心跳机制**，例如每隔 30 秒发送一个心跳包。
- **如果多次心跳无响应，可以主动关闭连接**，提升检测效率。

---

## 服务器 ping 不通但是 HTTP 能请求成功，会出现这种情况吗？什么原因造成的？

是的，这种情况是可能发生的。

### **原因分析**
- `ping` **使用的是 ICMP 协议，而 HTTP 走的是 TCP 协议。**
- 如果服务器的防火墙**禁用了 ICMP 协议**，但允许 TCP 连接，就会导致 `ping` 失败，但 HTTP 请求仍然可以成功。



---


## 如果业务对方给的 IP 和 端口号，我这边发起测试请求出错了，你会怎么排查？

### ✅ 1. **确认地址是否正确**
- 检查业务方给的 IP 和端口是否拼写正确。
- 例如，是否是 `http://192.168.1.100:8080`，有无多余的 `/`、空格或错别字。


### ✅ 2. **检查本地网络连通性**

使用命令行工具测试网络是否通：
#### **Ping IP 是否能通**
```bash
ping 192.168.1.100
```

> 如果 ping 不通，可能是网络不通、防火墙或对方不允许 ICMP。

#### **Telnet 测试端口是否开放**
```bash
telnet 192.168.1.100 8080
```

或者：
```bash
nc -vz 192.168.1.100 8080
```

如果 telnet 连不上，说明对方端口可能没开、被防火墙拦截，或服务没启动。


### ✅ 3. **确认服务是否真的在运行**

- 可向业务方确认：这个 IP 和端口上的服务是否已经启动？
- 如果有权限，也可以用 nmap 探测：
```bash
nmap -p 8080 192.168.1.100
```

#### 功能范围对比

|工具|能力范围|场景适用性|
|---|---|---|
|`ping`|判断主机是否在线（ICMP）|最基础连通性检测|
|`nc`|判断端口是否可连接（TCP/UDP）|更精细，判断“端口级别”的连通性|
|`nmap`|判断端口状态（open、filtered、closed），可识别服务和版本|更全面：不仅看“能不能连上”，还能分析服务、操作系统等|

#### 实际使用上的区别：

#### ✔ `ping`：
- 只能判断主机能否响应 ICMP 请求；
- 如果对方服务器禁用了 ICMP（很常见），你就 ping 不通，但它可能**服务是正常的**！

#### ✔ `nc`：
- 非常轻量级，能快速判断端口是否能连接；
- 但是只能返回**通或不通**，无法判断端口是被防火墙拦了，还是服务没开；
- 也不能识别端口上运行的是什么服务。

#### ✔ `nmap`：
- 能明确指出：端口是 `open`（开放）、`closed`（未监听）、还是 `filtered`（被防火墙拦截）；
- 能识别端口上运行的服务（如 nginx、apache），甚至版本号（配合 `-sV` 参数）；
- 可一次性扫描多个端口，甚至整个 IP 段。


### 举个真实排查的例子：

我曾经遇到过这样的场景：
> 某个对接系统的接口连不上，`ping` 不通，`nc` 也连不上。

但我用：
bash
```bash
nmap -p 8080 192.168.1.100
```

结果显示：
```bash
8080/tcp filtered
```
我就知道，不是服务没开，而是**中间网络设备（可能是防火墙）把请求拦了**。
于是我联系了对方网络管理员，他确认了确实有安全组规则没放行我们的 IP。问题就解决了。



### ✅ 4. **抓包分析请求数据**
- 使用 Wireshark / tcpdump 抓取你发出的请求，看是否真的发送成功、有无响应。
- 重点看：
    - TCP 三次握手是否成功；
    - 是否有 RST 包；
    - HTTP 请求格式是否正确；
    - 是否被防火墙拦截。


### ✅ 5. **检查 HTTP 请求是否格式正确**
- 比如是否使用了正确的方法（GET/POST），是否带上了必需的 header、body。
- 使用 Postman 或 curl 手动构造请求测试。
```bash
curl -v http://192.168.1.100:8080/api/test
```


### ✅ 6. **查看自身服务或日志**
- 如果是通过代码或应用调用的，查看日志中具体的错误信息（如 Connection refused, timeout, 403 等）；
- 确认是不是自身服务配置有问题，比如代理、DNS 等设置。


### ✅ 7. **跨主机排查（如果有）**
- 如果你在 Linux 服务器上测试失败，但在本机测试成功，可能是服务只绑定了 `localhost`；
- 也可能是服务器之间防火墙屏蔽了流量。