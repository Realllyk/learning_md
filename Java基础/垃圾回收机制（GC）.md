## 可达性分析（Reachability Analysis）
在 Java 的垃圾回收（Garbage Collection, GC）机制中，**可达性分析（Reachability Analysis）** 是判断对象是否存活的核心算法。

### 为什么不使用引用计数器
在 Java 中，对象存储在**堆（Heap）** 中。垃圾回收器（GC）需要定期清理**不再被使用的对象**，以释放内存。但是：
- 不能简单地**基于引用计数**来判断对象是否存活，因为**循环引用**会导致内存泄漏（因此 Java **不采用引用计数法**）。
- 需要**更可靠的方法**来判断哪些对象可以被回收，哪些对象仍然存活。
**可达性分析法（Reachability Analysis）** 就是 Java GC 用来判断对象是否存活的主要方法。

### 基本思想
如果一个对象可以通过一系列“可达”路径从 **GC Roots** 访问到，那么它是存活的，否则就是垃圾对象。

### 可达性分析过程
1. **从 GC Roots 出发，进行深度搜索（DFS）**，所有**可达的对象**都被标记为“存活”。
2. **不可达的对象** 被视为垃圾，在下一次 GC 中可能被回收。

### 什么是GC Roots
在 Java 中，**GC Roots（垃圾回收根对象）** 是可达性分析的起点。GC Roots 是一组特殊的对象，GC 认为它们是**绝对存活的**，所以任何可达 GC Roots 的对象都不会被回收。

| **GC Roots 类型**                   | **描述**                                      |
| --------------------------------- | ------------------------------------------- |
| **JVM 栈中的引用**                     | 方法栈（栈帧）中**正在执行的方法的局部变量**（即方法的局部变量、参数等）。     |
| **方法区中的静态变量**                     | 类的静态变量（`static` 修饰的成员变量）。                   |
| **方法区中的常量**                       | `final` 常量池中的对象（`String` 常量池等）。             |
| **JNI（本地方法）引用**                   | `Native` 代码（如 C/C++）中引用的 Java 对象。           |
| **Java 线程**                       | 正在执行的 Java 线程对象。                            |
| **系统类加载器（Bootstrap ClassLoader）** | 被 JVM 加载的基础类，如 `java.lang.Object`、`Thread`。 |

### GC处理不可达对象
在 **可达性分析** 中，GC 进行 **两次标记**：
1. **第一次标记（对象不可达）**：
    - 发现对象不可达，进入 **“即将回收状态”**。
    - **如果对象覆盖了 `finalize()` 方法**，GC 会将该对象放入 `F-Queue`（Finalizer Queue）。
    - `Finalizer` 线程执行 `finalize()` 方法（仅执行一次）。
    - **对象仍然有机会“复活”自己**（例如，把 `this` 赋值给某个 GC Roots 变量）。
2. **第二次标记**：
    - `finalize()` 方法执行后，GC 会再次进行可达性分析：
        - **如果对象成功“复活”**（被某个变量重新引用），则不会被回收。
        - **如果对象仍然不可达**，它将被真正回收。

<span style="color: orange;">在 JDK 9 及以后，`finalize()` 被标记为废弃（`@Deprecated`）</span>