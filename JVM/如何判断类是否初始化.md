# Java 类加载与类加载器总结

## 一、类的生命周期

在 JVM 中，一个类从字节码文件到真正被使用，大致经历以下阶段：

1. **加载（Loading）**
   - 作用：读取 `.class` 字节码文件，生成 `Class` 对象。
   - 结果：JVM 内存中出现 `Class<?>` 实例，可以通过 `Xxx.class` 拿到。
   - 注意：此时静态变量还没赋值，静态块未执行。

2. **连接（Linking）**
   - **验证（Verification）**：检查字节码是否合法、是否符合安全规范。
   - **准备（Preparation）**：为静态变量分配内存并赋 **默认值**（如 `0`、`null`）。
   - **解析（Resolution）**：把常量池中的符号引用解析成直接引用。

3. **初始化（Initialization）**
   - 作用：执行 `<clinit>` 方法，即：
     - 静态变量的 **显式赋值**
     - 静态代码块
   - 此阶段才算“类被执行过”。

4. **使用（Using）**
   - 正常使用类：创建对象、调用方法、访问字段等。

5. **卸载（Unloading）**
   - 类对应的 `ClassLoader` 被回收时，类也会被卸载。
   - 只在自定义类加载器 + 特殊场景下常见（如热加载）。

---

## 二、如何检查类的状态

### 1. 检查类是否 **已加载**
- **Class 对象存在** → 说明已加载。
- 可以通过 `ClassLoader.findLoadedClass(className)` 检查：
  ```java
  ClassLoader cl = Demo.class.getClassLoader();
  Class<?> c = cl.findLoadedClass("MyClass");
  if (c == null) {
      System.out.println("MyClass 尚未加载");
  } else {
      System.out.println("MyClass 已经加载");
  }
  ```

- 更底层：通过 **Instrumentation API** 或 **JVMTI** 遍历 `getAllLoadedClasses()`。

### 2. 检查类是否 **已初始化**
- Java 层没有直接 API，但可以借助静态标志位：
  ```java
  public class MyClass {
      public static boolean inited = false;
      static {
          inited = true;
          System.out.println("初始化完成");
      }
  }
  ```
- 访问 `MyClass.inited` 就能判断 `<clinit>` 是否执行过。

---

## 三、类加载器分类与作用

### 1. 启动类加载器（Bootstrap ClassLoader）
- 由 C++ 实现，JVM 内部的一部分。
- 加载 **核心类库**：`$JAVA_HOME/lib` 下的 `rt.jar`（JDK8）或基础模块（JDK9+）。
- 示例类：
  - `java.lang.String`
  - `java.util.HashMap`

### 2. 扩展类加载器（Extension ClassLoader / Platform ClassLoader）
- JDK8：加载 `$JAVA_HOME/lib/ext/` 目录下的 jar 包。
- JDK9+：改为 **PlatformClassLoader**，加载标准扩展模块（如 `java.sql.*`、`java.xml.*`）。
- 示例类：
  - `javax.crypto.Cipher`
  - `java.sql.Driver`

### 3. 应用类加载器（AppClassLoader / SystemClassLoader）
- 加载应用程序的 **classpath** 下的类。
- 包括：`target/classes`、依赖的 jar 包。
- 示例类：
  - 业务类 `com.example.Main`
  - 第三方依赖（Spring、MyBatis 等）

### 4. 自定义类加载器（Custom ClassLoader）
- 继承 `ClassLoader`，重写 `findClass`。
- 常用于：热部署、脚本引擎、加密字节码加载。

---

## 四、双亲委派机制

### 1. 原理
- 类加载请求会先交给父加载器处理，父加载器无法处理时才由当前加载器尝试。
- 伪代码（`loadClass` 方法）：
  ```java
  Class<?> loadClass(String name, boolean resolve) {
      Class<?> c = findLoadedClass(name);
      if (c == null) {
          try {
              c = parent.loadClass(name, false);
          } catch (ClassNotFoundException e) {
              c = findClass(name);
          }
      }
      return c;
  }
  ```

### 2. 好处
- 保证核心类库的唯一性和安全性（防止用户自定义 `java.lang.String` 等类）。
- 避免重复加载。

---

## 五、总结表格

| 阶段       | 作用                                   | 是否执行静态变量赋值/静态块 |
|------------|--------------------------------------|--------------------------|
| 加载       | 读取字节码，创建 `Class` 对象           | 否                       |
| 连接-准备  | 静态变量分配内存，赋默认值              | 否                       |
| 连接-解析  | 符号引用 → 直接引用                    | 否                       |
| 初始化     | 执行 `<clinit>`，静态变量赋值 & 静态块   | 是                       |
| 使用       | new 对象、调用方法                     | -                        |
| 卸载       | GC 回收类加载器                        | -                        |
