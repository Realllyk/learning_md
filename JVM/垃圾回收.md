## G1 回收器标记阶段与写屏障机制整理

G1 垃圾回收器在进行 Full GC 或 Mixed GC 时，会执行一套三阶段的标记过程，以识别所有存活对象。为保证准确性和效率，部分阶段需要 STW（Stop The World），部分可以并发执行。


### 一、标记阶段概述

G1 的标记过程主要分为三个阶段
#### 1️⃣ 初始标记（Initial Mark）
- **是否 STW：** 是
- **任务：** 标记 GC Roots 直接引用到的对象（第一层）    
- **说明：** 不会遍历完整堆或引用链，仅处理根对象，耗时非常短

#### 2️⃣ 并发标记（Concurrent Mark）
- **是否 STW：** 否
- **任务：** 从 GC Roots 出发遍历整个堆对象图，找出可达的存活对象
- **说明：** 该过程与应用线程并发执行，通过写屏障机制追踪引用变动，确保并发期间的引用变动不会导致漏标

#### 3️⃣ 再标记（Remark）
- **是否 STW：** 是
- **任务：** 对并发标记期间发生引用变更的区域重新扫描，确保标记结果准确
- **说明：** 借助写屏障记录的变动区域，只需增量处理引用变动部分，时间比并发标记短很多


### 二、为何初始标记和再标记需要 STW？
#### 🔸 初始标记
- 需要冻结线程，确保 GC Roots 的引用快照一致；
- 若不 STW，引用可能在扫描过程中变化，导致不准确；
- 因只处理第一层引用，耗时极短。

#### 🔸 再标记
- 并发标记期间程序仍可能修改引用；
- 通过写屏障机制记录引用变动，需 STW 重新处理这些变动区域；
- 只处理变化部分，时间短但必须 STW 以确保精确性。

### 三、写屏障机制在并发标记中的作用

#### ✅ 什么是写屏障（Write Barrier）？
- 是 JVM 在对象引用赋值操作时插入的钩子逻辑，用于追踪引用变动；
- 让 GC 在并发标记过程中也能感知引用关系的变更。

#### ✅ 工作机制
- 当对象引用发生变更，如：`A.field = B;`
    - 写屏障会记录 `A` 所在内存卡页为“脏页”（已变更）；
    - 把这个卡页加入 **Remembered Set（记忆集合）** 中；
- GC 在“再标记阶段”会专门处理这些卡页，确保变动的引用也能被标记。

#### ✅ 为什么不使用读屏障？
- 读屏障开销大，G1 不采用；ZGC 和 Shenandoah 使用读屏障，但设计更复杂。

### 四、总结表格

|阶段|是否 STW|工作内容|耗时特征|
|---|---|---|---|
|初始标记|✅ 是|标记 GC Roots 直接引用对象|极短|
|并发标记|❌ 否|遍历整个堆，找出所有可达对象|较长但并发进行|
|再标记|✅ 是|扫描引用变动区域，确保完整性|较短|


### 五、写屏障作用小结

| 行为         | 写屏障作用                    |
| ---------- | ------------------------ |
| 修改引用对象     | 标记所在卡页为“已变更”             |
| 写入字段       | 加入 Remembered Set 供再标记处理 |
| 并发期间追踪引用变化 | 避免遗漏活对象，提高并发标记准确性        |
s

写屏障机制和三阶段标记配合，使 G1 GC 在并发标记时既能保持高吞吐量，又能保证对象标记的准确性。