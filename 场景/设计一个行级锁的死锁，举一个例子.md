![[行级死锁.webp]]


## 死锁原因

### 1. 间隙锁（Gap Lock）机制
- **触发条件**：
    - 隔离级别为 **可重复读（Repeatable Read）**。
    - 使用 `SELECT ... FOR UPDATE` 查询不存在的记录（如 `order_no=1007`）。
- **锁范围**：
    - 锁定目标记录所在的间隙（例如，若当前存在 `order_no=1000` 和 `1010`，则锁定 `(1000, 1010)`）。
    - **共享性**：多个事务可同时持有同一间隙的间隙锁（S-Lock）。

### 2. 插入意向锁（Insert Intention Lock）冲突
- **插入操作需求**：
    - 插入新记录时需获取插入意向锁（一种特殊的间隙锁）。
- **冲突规则**：
    - 插入意向锁与已有的间隙锁**冲突**。
    - 事务 A 持有间隙锁时，事务 B 的插入操作需等待事务 A 释放锁，反之亦然。

### 3. 循环等待形成死锁
- 事务 A 等待事务 B 释放间隙锁以插入 `1007`。
- 事务 B 等待事务 A 释放间隙锁以插入 `1008`。
- **结果**：MySQL 检测到死锁，回滚其中一个事务。

---
## 常见误解与澄清
### 误解 1：“间隙锁不重叠则不会死锁”
- **澄清**：
    - 即使插入的值不同（如 1007 和 1008），若间隙锁范围重叠（如 `(1000, 1010)`），插入意向锁仍会冲突。
    - 间隙锁的共享性允许同时持有，但插入操作需升级为排他锁，导致互相阻塞。

### 误解 2：“间隙锁是互斥的”
- **澄清**：
    - 间隙锁是共享锁（S-Lock），多个事务可同时持有同一间隙锁。
    - 死锁的根源是插入意向锁与间隙锁的冲突，而非间隙锁本身。

---

## 解决方案
### 1. 优化锁范围
- **方法**：
    - 使用唯一索引（如 `order_no`），缩小间隙锁范围。
    - 避免全表扫描（确保查询条件命中索引）。

### 2. 控制事务顺序
- **规则**：
    - 按固定顺序操作资源（如先处理较小的 `order_no`）。

### 3. 使用乐观锁
- **实现**：
    - 通过版本号或 CAS（Compare-And-Swap）减少锁竞争。
    - 示例：先查询当前 `order_no` 最大值，插入时校验。

### 4. 调整隔离级别
- **读已提交（Read Committed）**：
    - 在该级别下，InnoDB 不使用间隙锁，但可能引入幻读。


---

## 扩展知识

### 间隙锁的触发场景

|操作|是否触发间隙锁（RR 隔离级别）|
|---|---|
|`SELECT ... FOR UPDATE`（记录不存在）|✔️|
|`UPDATE` 非唯一索引列|✔️|
|`INSERT`（隐式触发插入意向锁）|❌|

### 死锁检测与处理

- **检测机制**：InnoDB 使用等待图（Wait-for Graph）检测循环依赖。
    
- **处理策略**：回滚代价较小的事务（根据事务的更新量判断）。