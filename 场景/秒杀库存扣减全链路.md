
# 秒杀库存扣减全链路（从前端到 DB）— 实战流程与数据结构（含示例代码）

> 场景：极高并发、极少库存、极热 SKU、极短生命周期。目标：**不超卖、低延迟、可回滚、可审计**。  
> 推荐组合：**入口限流** → **Redis 原子预减（含预留）** → **MQ 按 SKU 分区串行消费** → **DB 记账（账本法优先）** → **对账与补偿**。

---

## 0. 名词与约定

- **SKU（Stock Keeping Unit）**：库存最小管理单元，例如“红色/M 码 T 恤”。唯一标识用 `sku_id`。  
- **库存总量**：`total_stock` —— 活动起始时可售的“基数”。  
- **已售量**：由 DB 记账得到（推荐用“账本法”汇总得到，而不是直接维护单行自增）。  
- **可售量**：`available = total_stock - sold`。活动中**入口**由 Redis 保护，避免并发打 DB。  
- **预留量（reserve）**：Redis 层**临时占位**（订单待支付）。Key 用 `reserve:{sku_id}` 的 `Hash(token -> qty)` 表示，带 TTL。  
- **order_token**：订单幂等键（如 `user_id + activity_id + sku_id` 的哈希）。

> 贯穿全链路的两个关键：**幂等**（token 级唯一）与 **单 SKU 单写者**（MQ 分区 + 单线程消费）。

---

## 1. 前端与网关（限流 + 幂等发起）

### 1.1 数据与接口
- 前端携带/或由后端生成：`order_token`、`sku_id`、`qty`。  
- 网关/应用做滑动窗口/令牌桶限流，过滤大部分“无效流量”。

### 1.2 伪代码（Java / Spring 表意）
```java
@PostMapping("/seckill/try")
public SeckillTryResp trySeckill(@RequestBody SeckillTryReq req) {
    // 1) 基础校验与限流（省略）
    String token = req.getOrderToken();
    long skuId = req.getSkuId();
    int qty = req.getQty();

    // 2) 调用 Redis Lua 进行原子预减（见 §2.2）
    boolean ok = redisReserveLua(skuId, token, qty, /*ttlSecs*/ 300);
    if (!ok) return SeckillTryResp.fail("Sold out");

    // 3) 发送消息到 MQ（分区键=skuId 或 虚拟桶）
    mq.send("seckill-orders", /*key*/ String.valueOf(skuId),
            SeckillMsg.of(token, skuId, qty, System.currentTimeMillis()));

    // 4) 立即返回“抢到名额”，后续由异步链路完成 DB 记账/订单确认
    return SeckillTryResp.ok(token);
}
```

---

## 2. Redis 原子预减（扣减可售 + 记录预留）

### 2.1 Key 设计（基础版）
- `stock:{sku_id}`：整型，可售库存计数器（活动前装载为 `total_stock`）。
- `reserve:{sku_id}`：`Hash`，字段为 `order_token`，值为 `qty`；设置 `EXPIRE` 作为**支付超时**的兜底。

> **热点 SKU** 可启用“虚拟桶”方案把一个 SKU 拆为 N 个桶：  
> `stock:{sku_id}:{bucket}`，`reserve:{sku_id}:{bucket}`；请求时对 `bucket = hash(order_token) % N`。

### 2.2 预减 Lua（原子）
```lua
-- KEYS[1] = stock:{sku_id}         或 stock:{sku_id}:{bucket}
-- KEYS[2] = reserve:{sku_id}       或 reserve:{sku_id}:{bucket}
-- ARGV[1] = order_token
-- ARGV[2] = qty
-- ARGV[3] = ttl_secs
local stock = tonumber(redis.call("GET", KEYS[1]) or "0")
local qty = tonumber(ARGV[2])
if stock < qty then
  return 0  -- 不足，直接失败
end
redis.call("DECRBY", KEYS[1], qty)                     -- 可售减去
redis.call("HINCRBY", KEYS[2], ARGV[1], qty)           -- 记录预留
redis.call("EXPIRE", KEYS[2], tonumber(ARGV[3]))       -- 预留过期自动兜底
return 1
```

### 2.3 取消/超时释放 Lua（幂等）
```lua
-- KEYS[1] = stock:{sku_id}
-- KEYS[2] = reserve:{sku_id}
-- ARGV[1] = order_token
local reserved = tonumber(redis.call("HGET", KEYS[2], ARGV[1]) or "0")
if reserved > 0 then
  redis.call("INCRBY", KEYS[1], reserved)  -- 可售加回
  redis.call("HDEL", KEYS[2], ARGV[1])     -- 删除预留记录
end
return reserved  -- 返回本次释放的数量（0 说明已释放过或不存在，满足幂等）
```

---

## 3. MQ：按 SKU 分区，单线程消费

### 3.1 分区策略
- **分区键**：`sku_id`（或“虚拟桶键”如 `sku_id#bucket`）。  
- **原则**：**同一 SKU** 的消息进入**同一分区**，由**一个消费线程顺序处理** ⇒ **单 SKU 单写者**。  
- **分区数**（例如 32/64/128）≪ SKU 数量；多个 SKU 共享分区以均衡负载。

### 3.2 消息体（JSON）
```json
{
  "order_token": "tok_abc123",
  "sku_id": 100200300,
  "qty": 1,
  "ts": 1736987654321
}
```

### 3.3 生产者（Java / Kafka 示例）
```java
ProducerRecord<String, byte[]> rec = new ProducerRecord<>(
    "seckill-orders",               // topic
    String.valueOf(skuId),          // key = 分区键（Kafka 会以此做哈希分区）
    jsonBytes(msg)                  // 消息体
);
kafka.send(rec);
```

---

## 4. DB 侧数据模型（MySQL 8 示例）

> 采用 **“主表 + 明细账本 + 订单 + Outbox”** 组合，**账本法优先**。

### 4.1 库存主表（相对静态）
```sql
CREATE TABLE inventory (
  sku_id       BIGINT       PRIMARY KEY,
  total_stock  INT          NOT NULL,       -- 活动前装载
  sold         INT          NOT NULL DEFAULT 0,  -- 可选统计列（用于快速读，异步校准）
  updated_at   TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB;
```

### 4.2 库存流水（账本法核心，append-only）
```sql
CREATE TABLE stock_txn (
  id           BIGINT       NOT NULL AUTO_INCREMENT PRIMARY KEY,
  order_token  VARCHAR(64)  NOT NULL,
  sku_id       BIGINT       NOT NULL,
  qty          INT          NOT NULL,
  action       ENUM('CONFIRM','CANCEL') NOT NULL,
  created_at   TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP,
  UNIQUE KEY uk_txn (order_token, sku_id, action),
  KEY idx_txn_sku_ct (sku_id, created_at)
) ENGINE=InnoDB;
```

### 4.3 订单表（状态 CAS，解决竞态）
```sql
CREATE TABLE orders (
  order_token  VARCHAR(64)  NOT NULL PRIMARY KEY,
  sku_id       BIGINT       NOT NULL,
  qty          INT          NOT NULL,
  status       ENUM('PENDING','CONFIRMED','CANCELED') NOT NULL DEFAULT 'PENDING',
  created_at   TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP,
  KEY idx_orders_status_ct (status, created_at)
) ENGINE=InnoDB;
```

### 4.4 Outbox（可靠消息/重放）
```sql
CREATE TABLE outbox (
  id          BIGINT       NOT NULL AUTO_INCREMENT PRIMARY KEY,
  event_type  VARCHAR(64)  NOT NULL,
  payload     JSON         NOT NULL,
  status      ENUM('PENDING','SENT','FAILED') NOT NULL DEFAULT 'PENDING',
  created_at  TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP,
  KEY idx_outbox_status_ct (status, created_at)
) ENGINE=InnoDB;
```

### 4.5 视图（把“余额=流水聚合”封装起来，便于查询/对账）
> MySQL 无原生物化视图；线上高并发场景建议**把结果缓存**或用**定时刷新表**。

```sql
CREATE OR REPLACE VIEW inventory_view AS
SELECT i.sku_id,
       i.total_stock,
       COALESCE(SUM(CASE WHEN t.action='CONFIRM' THEN t.qty
                         WHEN t.action='CANCEL'  THEN -t.qty END), 0) AS sold_calc,
       (i.total_stock - COALESCE(SUM(CASE WHEN t.action='CONFIRM' THEN t.qty
                         WHEN t.action='CANCEL'  THEN -t.qty END), 0)) AS available_calc
FROM inventory i
LEFT JOIN stock_txn t ON t.sku_id = i.sku_id
GROUP BY i.sku_id, i.total_stock;
```

---

## 5. 消费者落库流程（账本法 / 原子自增法）

> **前提**：同一 SKU 的消息在同一分区，序消费；消息幂等由唯一键保证。

### 5.1 账本法（推荐）
```sql
-- 事务开始
START TRANSACTION;

-- 幂等插入流水（重复消息不会产生副作用）
INSERT INTO stock_txn(order_token, sku_id, qty, action)
VALUES (?, ?, ?, 'CONFIRM')
ON DUPLICATE KEY UPDATE id = id;

-- 订单状态：仅允许 PENDING -> CONFIRMED
UPDATE orders SET status='CONFIRMED'
WHERE order_token=? AND status='PENDING';

-- 可靠事件（Outbox，用于下游通知/发货等）
INSERT INTO outbox(event_type, payload, status)
VALUES ('STOCK_CONFIRMED', JSON_OBJECT('order_token', ?, 'sku_id', ?, 'qty', ?), 'PENDING');

COMMIT;
```

**取消/超时（CANCEL）**：
1) 先执行 **Redis 释放 Lua**（§2.3）；  
2) 然后 DB 里**追加一条** `CANCEL` 流水（同样幂等），订单状态 `PENDING -> CANCELED`。

```sql
START TRANSACTION;
INSERT INTO stock_txn(order_token, sku_id, qty, action)
VALUES (?, ?, ?, 'CANCEL')
ON DUPLICATE KEY UPDATE id = id;

UPDATE orders SET status='CANCELED'
WHERE order_token=? AND status='PENDING';

INSERT INTO outbox(event_type, payload, status)
VALUES ('ORDER_CANCELED', JSON_OBJECT('order_token', ?, 'sku_id', ?, 'qty', ?), 'PENDING');
COMMIT;
```

### 5.2 原子自增法（简单，但更依赖“单写者”）
> 在插入幂等流水后，直接对主表做自增；取消时做补偿自减（仅当曾确认过）。

```sql
-- CONFIRM
START TRANSACTION;
INSERT INTO stock_txn(order_token, sku_id, qty, action)
VALUES (?, ?, ?, 'CONFIRM')
ON DUPLICATE KEY UPDATE id = id;

UPDATE orders SET status='CONFIRMED'
WHERE order_token=? AND status='PENDING';

UPDATE inventory SET sold = sold + ?
WHERE sku_id = ?;

INSERT INTO outbox(event_type, payload, status)
VALUES ('STOCK_CONFIRMED', JSON_OBJECT('order_token', ?, 'sku_id', ?, 'qty', ?), 'PENDING');
COMMIT;

-- CANCEL（仅当该单曾 CONFIRM）
START TRANSACTION;
INSERT INTO stock_txn(order_token, sku_id, qty, action)
VALUES (?, ?, ?, 'CANCEL')
ON DUPLICATE KEY UPDATE id = id;

UPDATE orders SET status='CANCELED'
WHERE order_token=? AND status='PENDING';

-- 确认过才补偿自减（用 EXISTS 保障）
UPDATE inventory i
JOIN (SELECT 1 FROM stock_txn 
      WHERE order_token=? AND sku_id=? AND action='CONFIRM' LIMIT 1) c ON 1=1
SET i.sold = i.sold - ?
WHERE i.sku_id = ?;

INSERT INTO outbox(event_type, payload, status)
VALUES ('ORDER_CANCELED', JSON_OBJECT('order_token', ?, 'sku_id', ?, 'qty', ?), 'PENDING');
COMMIT;
```

---

## 6. “超时/支付失败”的触发方式（两套）

1) **延迟队列（推荐）**：下单时发送 `order_timeout` 延迟消息（延时=支付时限）；消费时若订单仍为 `PENDING` → 走 CANCEL（§5.1 流程）。  
2) **定时扫描**：周期性扫描 `orders` 表：`status='PENDING' AND created_at < now()-T` → 逐单发 CANCEL。

> 两者可同时存在，延迟队列为主，定时扫描兜底。

---

## 7. 对账与补偿（兜底闭环）

- **Redis vs DB**：定时对比 `stock:{sku}` + `reserve:{sku}` 的汇总 与 `inventory_view.available_calc`；  
- 发现差异超阈值：自动发“冲正任务”（按 `order_token` 重放/补写流水或重建 Redis）；  
- 监控指标：Lua 失败率、MQ 堆积、订单状态 CAS 失败率、Outbox 积压、Redis/DB 差异水位。

---

## 8. 全链路时序（ASCII 简图）

```
[Client] --try--> [API/Gateway] --Lua预减--> [Redis]
     | 成功(抢到名额)               | 可售-qty, reserve[token]=qty
     |                              v
     |                         [MQ(seckill-orders)  按 sku_id 分区] ---> 分区内单线程
     |                                                                    |
     |                                                                    v
     |                                                          [Consumer / Service]
     |                                                                    |
     |                                                          DB事务: 账本法/自增法
     |                                                           - stock_txn 追加
     |                                                           - orders PENDING->CONFIRMED
     |                                                           - outbox 记录
     v
[页面提示“抢到名额，待支付”]
```

**取消/超时**：  
延迟消息/定时任务 → Redis Lua 释放（可售+qty, 删除 reserve[token]）→ DB 追加 `CANCEL` 流水 & 订单 `PENDING->CANCELED`。

---

## 9. 关键实践清单

- **分区键**：`sku_id`（或“虚拟桶键”），确保同一 SKU 串行消费。  
- **幂等**：`stock_txn.uk_txn` + 订单状态 CAS。  
- **Redis**：活动前预热 `stock:{sku}`；`reserve` 必须带 TTL；Lua 原子。  
- **视图/缓存**：线上读走缓存或“物化结果表”，离线/对账走 `inventory_view` 聚合。  
- **热点**：虚拟桶（N 个 Key 与 N 个分区），尾盘合并记账。

---

### 附：最小 Java 消费者骨架（仅示意）
```java
@KafkaListener(topics = "seckill-orders", containerFactory = "kafkaListenerContainerFactory")
public void onMessage(ConsumerRecord<String, byte[]> rec) {
    SeckillMsg msg = fromJson(rec.value());
    String token = msg.getOrderToken();
    long skuId = msg.getSkuId();
    int qty = msg.getQty();

    // DB 事务（账本法）
    txTemplate.executeWithoutResult(tx -> {
        jdbc.update("INSERT INTO stock_txn(order_token, sku_id, qty, action) " +
                    "VALUES (?, ?, ?, 'CONFIRM') ON DUPLICATE KEY UPDATE id = id",
                    token, skuId, qty);

        int updated = jdbc.update("UPDATE orders SET status='CONFIRMED' " +
                                  "WHERE order_token=? AND status='PENDING'", token);
        // 即使 updated=0（可能已被取消/重复确认），也保持幂等不再继续其他“会改变余额”的操作

        jdbc.update("INSERT INTO outbox(event_type, payload, status) VALUES " +
                    "('STOCK_CONFIRMED', JSON_OBJECT('order_token', ?, 'sku_id', ?, 'qty', ?), 'PENDING')",
                    token, skuId, qty);
    });
}
```

---

> **结论**：把“防超卖”放在 **Redis**（原子预减），把“并发冲突”消解在 **MQ 分区**（单 SKU 串行），把“最终一致与审计”放在 **DB 账本法**（流水追加 + 视图聚合 + Outbox + 对账），即可在秒杀强压下获得“快 & 准 & 可恢复”的库存系统。

