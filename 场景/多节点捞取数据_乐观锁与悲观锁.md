# 分布式任务领取中的悲观锁与乐观锁方案对比

## 一、悲观锁方案（SELECT ... FOR UPDATE SKIP LOCKED）

### 流程（MySQL 8.0+）

1.  **领取（短事务）**

    ``` sql
    BEGIN;
    SELECT id
      FROM job_task
     WHERE status = 0
     ORDER BY id
     LIMIT 100
     FOR UPDATE SKIP LOCKED;
    UPDATE job_task
       SET status = 1, locked_by = :worker, locked_at = NOW()
     WHERE id IN (...);
    COMMIT;
    ```

    > 加锁立即生效，必须尽快提交，避免长事务。

2.  **处理**：在事务外执行，避免持锁。

3.  **回写结果（短事务）**

    ``` sql
    BEGIN;
    UPDATE job_task
       SET status = :final_status
     WHERE id IN (...) AND locked_by = :worker;
    COMMIT;
    ```

4.  **超时回收（定时任务）**

    ``` sql
    UPDATE job_task
       SET status=0, locked_by=NULL
     WHERE status=1 AND locked_at < NOW() - INTERVAL 30 MINUTE;
    ```

### 优点

-   语义直观：谁先锁谁处理，天然避免重复。\
-   SQL 层实现简单，不需要额外版本号。\
-   `SKIP LOCKED` 保证并发下不互相阻塞。

### 缺点

-   依赖 MySQL 8.0+。\
-   领取事务必须非常短；若异常未回滚，锁会一直持有，阻塞补偿任务。\
-   仅能保证单库内互斥，跨库需额外协调。

------------------------------------------------------------------------

## 二、乐观锁方案（CAS / 版本号）

### 表字段

需增加 `version` / `locked_by` / `locked_at` 等字段。

### 流程

1.  **领取（短事务或 autocommit）**

    ``` sql
    UPDATE job_task
       SET status=1, locked_by=:worker, locked_at=NOW(), version=version+1
     WHERE status=0
     ORDER BY id
     LIMIT 100;
    ```

    > 一次原子更新 + 提交，其他事务立刻可见。

2.  **处理**：在事务外进行。

3.  **回写结果（短事务，CAS 校验）**

    ``` sql
    BEGIN;
    UPDATE job_task
       SET status=:final_status, version=version+1
     WHERE id=:id AND locked_by=:worker AND status=1;
    COMMIT;
    ```

4.  **失败与回收**

    -   失败直接置 `FAILED`；或回退 `PENDING` 并增加 `retry_count`。\
    -   定时任务回收超时的 `PROCESSING`。

### 优点

-   无需依赖行锁，冲突时快速失败，吞吐扩展性好。\
-   可用于跨库/跨存储场景。\
-   领取与处理彻底解耦。

### 缺点

-   需要额外字段与重试逻辑。\
-   冲突严重时可能出现"重试风暴"。\
-   需依赖定时回收防止卡死。

------------------------------------------------------------------------

## 三、锁释放与异常场景

### 悲观锁（FOR UPDATE）

-   锁在语句执行成功时立即生效，直到事务 COMMIT/ROLLBACK 才释放。\
-   异常但连接未断开，若未回滚，锁会一直持有，阻塞补偿 UPDATE。\
-   连接断开或 MySQL 崩溃恢复时，InnoDB 会回滚未完成事务并释放锁。\
-   **实践要点**：领取事务必须极短，异常路径务必显式
    ROLLBACK，连接池需配置事务归还检查。

### 乐观锁（CAS）

-   领取事务提交后，其他事务立刻知道哪些任务被占用。\
-   处理失败再开启新事务更新为 FAILED 或 PENDING。\
-   超时卡死任务由定时回收。

------------------------------------------------------------------------

## 四、对比表

  --------------------------------------------------------------------------------
  对比点       悲观锁（SKIP LOCKED）                    乐观锁（CAS）
  ------------ ---------------------------------------- --------------------------
  并发模式     行锁直接避免冲突                         版本号检查，冲突重试

  实现难度     简单                                     需要额外字段与逻辑

  阻塞情况     不阻塞（跳过锁），但持锁事务需尽快提交   不阻塞，失败即放弃或重试

  适用范围     单库任务队列                             跨库/跨存储

  风险点       异常未回滚导致长时间持锁                 重试风暴，需回收机制
  --------------------------------------------------------------------------------

------------------------------------------------------------------------

## 五、最佳实践

-   **悲观锁**：推荐 MySQL 8.0+
    单库任务领取，关键是领取事务极短，处理与回写分离。\
-   **乐观锁**：推荐分布式、跨存储，靠 CAS 与版本号控制并发。\
-   **统一要求**：领取事务尽快提交，失败/超时要有补偿和回收机制。
