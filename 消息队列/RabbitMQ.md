
## RabbitMQ的消息可靠性机制

RabbitMQ 在设计上非常注重“端到端”的消息可靠性，主要体现在以下几个方面：

### 1. 持久化机制
- **Durable Queue**：队列持久化，Broker 重启后队列依然存在。
- **Persistent Message**：消息设置为持久化，写入磁盘而不是仅存在内存中。
- **注意**：只有队列和消息都持久化，消息才真正不会因重启丢失。

### 2. ACK 机制（确认机制）
- **自动 ACK**：消息一送达消费者即标记消费完成，存在丢失风险。
- **手动 ACK**：消费者处理完成后调用 `basicAck()` 显式确认，更可靠。
- **NACK / Reject**：当消费失败时，调用 `basicNack()` 或 `basicReject()` 进行拒绝处理，可以选择是否重新投递（`requeue`）。

### 3. 消费端宕机处理
- 消息被消费但未确认（`unacked`）时，若消费者断开连接，消息会被 RabbitMQ 自动重新投递给其他消费者。

### 4. 死信队列（DLQ）机制
- 当消息：
    - 被 `reject` 且 `requeue=false`
    - 消费失败重试超过次数
    - 消息/队列过期（TTL）
    可被转发至 **死信队列**（Dead Letter Queue），由专门消费者处理。

### 5. Broker 的概念
- **Broker** 是 RabbitMQ 的核心服务进程，负责接收、存储、路由和转发消息。
- 它处理生产者发送的消息，将其转发给队列，并协调消费者的消息获取。
- RabbitMQ 通常作为单个 Broker 实例运行，但也可以配置成集群模式实现高可用。


---

## RabbitMQ 的消息重试机制

RabbitMQ 原生不支持“自动重试 N 次”的配置，但通过如下机制实现重试逻辑：
### 1. 手动重试（代码控制）

```java
try {
    // 处理逻辑
    channel.basicAck(tag, false); // 消费成功
} catch (Exception e) {
    channel.basicNack(tag, false, true); // 重试一次
}
```

### 2. TTL + DLX 实现延迟重试
- 定义一个“延迟队列”，设置 TTL（消息生存时间）和 DLX（死信交换机）。
- 消息处理失败后进入延迟队列，延迟 N 秒后转发到主队列进行重试。

```
x-dead-letter-exchange: main-exchange
x-message-ttl: 5000
```

### 3. Spring Retry 支持（推荐）
- Spring AMQP 提供 `@Retryable` 注解或 `RetryTemplate` 机制，可以自动进行 N 次重试后将失败消息转入 DLQ。

### 4. 重试 + 死信组合策略
- 多次失败后转入 DLQ，由专门服务/人工进行补偿或报警。


---


## 对于RabbitMQ，如果消费者没有恢复ACK，消息是会从消息队列中出来，还是阻塞在队头

### ✅ 情况一：队列默认（**非“exclusive”/“单消费者”队列**）
- 消息被消费端拉取（或推送）后，进入消费者的“**未确认消息列表**”；
- 此时消息：
    - 不在原队列中（已经从 queue 中取出）；
    - 不会被其他消费者再看到（RabbitMQ 一条消息同一时间只能给一个消费者）；
    - 不会影响后续消息被推送给其他消费者（**不会卡住队头**）；
- 如果你一直不 ACK，也不拒绝，消息就会一直悬着，直到：
    - 消费者宕机 / 断开连接；
    - 超过某些重连、心跳设置，RabbitMQ 判定连接死掉；
    - 此时，这条“unacked 消息”会被重新投递回队列（**requeue**）


### ✅ 情况二：你用了“prefetch=1” 的限流机制
这是很多人会遇到“**消息卡在队头**”的根本原因！

```java
factory.setPrefetchCount(1);  // 每次最多只发1条给消费者
```

- 意思是：RabbitMQ 只在**上一条消息被 ACK 后**，才会发下一条；
- 所以你如果不 ACK，第 2 条消息永远不会发给你，**此时就表现为“卡队头”**；
- 适合严格顺序 + 单消费者场景，但默认场景不推荐。
